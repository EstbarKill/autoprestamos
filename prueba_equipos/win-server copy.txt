# ============================================================
# üéì SISTEMA DE AUTOPR√âSTAMOS - ARQUITECTURA DUAL PROCESS
# ============================================================
# Versi√≥n: 2.2 (Depuraci√≥n Completa - Error .Text Resuelto)
# ============================================================

Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing

# ============================================================
# üì¶ CONFIGURACI√ìN GLOBAL
# ============================================================

$Global:Config = @{
    ServidorWS    = "ws://localhost:8081"
    ApiUrl        = "http://localhost/autoprestamos/prueba_equipos/api.php"
    LogoPath      = "C:\xampp\htdocs\autoprestamos\dashboard-unisimon\assets\img\logo.png"
    IdEquipo      = $env:COMPUTERNAME
    Username      = $env:USERNAME
    ClaveAdmin    = "S1m0n_2025"
    MaxReintentos = 5
    TiempoReintento = 3
}

# Variables de sincronizaci√≥n entre procesos
$Global:SharedState = [hashtable]::Synchronized(@{
    WebSocketConnected = $false
    LastMessage = $null
    CommandQueue = [System.Collections.Queue]::Synchronized((New-Object System.Collections.Queue))
    LogQueue = [System.Collections.Queue]::Synchronized((New-Object System.Collections.Queue))
    MacAddress = $null
    SessionActive = $true
    WSClientReference = $null  # Referencia thread-safe al cliente WS
    LastActivity = (Get-Date)  # √öltimo timestamp de actividad del usuario
    IsHibernating = $false     # Flag de hibernaci√≥n actual
    HibernationStartTime = $null  # Cu√°ndo comenz√≥ la hibernaci√≥n
    OutgoingQueue = [System.Collections.Queue]::Synchronized((New-Object System.Collections.Queue))
    INACTIVITY_TIMEOUT = 30   # 5 minutos en segundos
    HIBERNATION_MAX_DURATION = 60  # 10 minutos adicionales en segundos
})

Add-Type @"
using System;
using System.Runtime.InteropServices;
public static class IdleTime {
    [StructLayout(LayoutKind.Sequential)]
    struct LASTINPUTINFO {
        public uint cbSize;
        public uint dwTime;
    }
    [DllImport("user32.dll")]
    static extern bool GetLastInputInfo(ref LASTINPUTINFO plii);
    public static uint GetIdleTime() {
        LASTINPUTINFO lastInputInfo = new LASTINPUTINFO();
        lastInputInfo.cbSize = (uint)Marshal.SizeOf(lastInputInfo);
        GetLastInputInfo(ref lastInputInfo);
        return ((uint)Environment.TickCount - lastInputInfo.dwTime) / 1000;
    }
}
"@

function Get-SystemIdleTime {
    return [IdleTime]::GetIdleTime()
}

function Write-Log {
    param(
        [string]$Mensaje,
        [ValidateSet('Info', 'Warning', 'Error', 'Success')]
        [string]$Tipo = 'Info'
    )
    
    $timestamp = Get-Date -Format 'HH:mm:ss'
    $prefijo = switch ($Tipo) {
        'Info'    { "‚ÑπÔ∏è" }
        'Warning' { "‚ö†Ô∏è" }
        'Error'   { "‚ùå" }
        'Success' { "‚úÖ" }
    }
    
    $color = switch ($Tipo) {
        'Info'    { 'White' }
        'Warning' { 'Yellow' }
        'Error'   { 'Red' }
        'Success' { 'Green' }
    }
    
    try {
        Write-Host "[$timestamp] $prefijo [$Tipo] $Mensaje" -ForegroundColor $color
    }
    catch {
        # Silenciar errores de logging para no romper el script
    }
}

function Enqueue-WSMessage {
    param([hashtable]$Payload)
    try {
        if (-not $Global:SharedState.ContainsKey('OutgoingQueue')) {
            $Global:SharedState.OutgoingQueue = [System.Collections.Queue]::Synchronized((New-Object System.Collections.Queue))
        }
        $Global:SharedState.OutgoingQueue.Enqueue($Payload)
        return $true
    }
    catch {
        Write-Log "‚ö†Ô∏è Error encolar mensaje WS: $_" -Tipo Warning
        return $false
    }
}

function Format-TimeSpan {
    param([int]$Segundos)
    $ts = [TimeSpan]::FromSeconds($Segundos)
    return "{0:00}:{1:00}:{2:00}" -f $ts.Hours, $ts.Minutes, $ts.Seconds
}

function Convert-ToColombiaDate {
    param([string]$UtcString)
    try {
        $dtUtc = [System.Xml.XmlConvert]::ToDateTime($UtcString, [System.Xml.XmlDateTimeSerializationMode]::Utc)
        $tzCol = [System.TimeZoneInfo]::FindSystemTimeZoneById("SA Pacific Standard Time")
        $dtCol = [System.TimeZoneInfo]::ConvertTimeFromUtc($dtUtc, $tzCol)
        return $dtCol.ToString("dddd, dd 'de' MMMM 'de' yyyy", [System.Globalization.CultureInfo]::GetCultureInfo("es-CO"))
    }
    catch {
        return $UtcString
    }
}

function Get-ActiveNetworkInterface {
    Write-Log "Detectando interfaz de red activa..." -Tipo Info
    
    $interfazActiva = Get-NetIPConfiguration |
        Where-Object { $_.IPv4DefaultGateway -ne $null -and $_.NetAdapter.Status -eq "Up" } |
        Select-Object -First 1
    
    if ($interfazActiva) {
        $mac = $interfazActiva.NetAdapter.MacAddress
        $nombre = $interfazActiva.NetAdapter.InterfaceAlias
        $ip = $interfazActiva.IPv4Address.IPAddress
        
        Write-Log "Interfaz detectada: $nombre (MAC: $mac)" -Tipo Success
        return @{ MAC = $mac; Nombre = $nombre; IP = $ip }
    }
    
    Write-Log "No se encontr√≥ interfaz con conexi√≥n a Internet" -Tipo Error
    return $null
}

# ============================================================
# üîå PROCESO WEBSOCKET INDEPENDIENTE (RUNSPACE)
# ============================================================

$Global:WebSocketRunspace = $null
$Global:WebSocketPowerShell = $null

function Start-WebSocketProcess {
    Write-Log "üîÑ Iniciando proceso WebSocket independiente..." -Tipo Info
    
    # Crear Runspace independiente
    $Global:WebSocketRunspace = [runspacefactory]::CreateRunspace()
    $Global:WebSocketRunspace.Open()
    
    # Compartir variables globales con el runspace
    $Global:WebSocketRunspace.SessionStateProxy.SetVariable("Config", $Global:Config)
    $Global:WebSocketRunspace.SessionStateProxy.SetVariable("SharedState", $Global:SharedState)
    
    # Crear PowerShell instance
    $Global:WebSocketPowerShell = [powershell]::Create()
    $Global:WebSocketPowerShell.Runspace = $Global:WebSocketRunspace
    
    # Script del proceso WebSocket
    $wsScript = {
function Write-WSLog {
    param([string]$Mensaje, [string]$Tipo = 'Info')

    $timestamp = Get-Date -Format 'HH:mm:ss'
    $prefijo = switch ($Tipo) {
        'Info' { "üåê" }; 'Warning' { "‚ö†Ô∏è" }; 'Error' { "‚ùå" }; 'Success' { "‚úÖ" }
    }

    # Mostrar en consola del proceso WebSocket
    Write-Host "[$timestamp] $prefijo [WS-PROCESS] $Mensaje"

    # Encolar log en la cola compartida
    try {
        if (-not $SharedState.ContainsKey('LogQueue')) {
            $SharedState.LogQueue = [System.Collections.Queue]::Synchronized((New-Object System.Collections.Queue))
        }
        $SharedState.LogQueue.Enqueue(@{ Mensaje = "[$timestamp] $Mensaje"; Tipo = $Tipo })
    }
    catch { }
}

        
        function Send-WSMessage {
            param($WsClient, [hashtable]$Payload)
            
            if (-not $WsClient -or $WsClient.State -ne [System.Net.WebSockets.WebSocketState]::Open) {
                return $false
            }
            
            try {
                $json = $Payload | ConvertTo-Json -Compress
                $bytes = [System.Text.Encoding]::UTF8.GetBytes($json)
                $segment = [System.ArraySegment[byte]]::new($bytes)
                $WsClient.SendAsync($segment, [System.Net.WebSockets.WebSocketMessageType]::Text, $true, [Threading.CancellationToken]::None).Wait(3000)
                return $true
            }
            catch {
                Write-WSLog "Error al enviar mensaje: $_" -Tipo Error
                return $false
            }
        }
        
        function Connect-WSClient {
            param([int]$MaxReintentos = 5)
            
            $intentos = 0
            $uri = [System.Uri]$Config.ServidorWS
            
            while ($intentos -lt $MaxReintentos -and $SharedState.SessionActive) {
                try {
                    Write-WSLog "Conectando a $($Config.ServidorWS) (intento $($intentos + 1)/$MaxReintentos)..." -Tipo Info
                    
                    $ws = [System.Net.WebSockets.ClientWebSocket]::new()
                    $ws.ConnectAsync($uri, [Threading.CancellationToken]::None).Wait()
                    
                    if ($ws.State -eq [System.Net.WebSockets.WebSocketState]::Open) {
                        Write-WSLog "‚úÖ Conectado exitosamente" -Tipo Success
                        
                        # Registrar cliente
                        $registrado = Send-WSMessage -WsClient $ws -Payload @{
                            tipo = "registro"
                            accion = "getRegistro"
                            origen = "equipo"
                            nombre_equipo = $Config.IdEquipo
                        }
                        
                        if ($registrado) {
                            Write-WSLog "üìù Cliente registrado: $($Config.IdEquipo)" -Tipo Success
                            $SharedState.WebSocketConnected = $true
                            $SharedState.WSClientReference = $ws
                            return $ws
                        }
                    }
                }   
                catch {
                    Write-WSLog "Error de conexi√≥n: $_" -Tipo Error
                }
                
                $intentos++        
        # üîÅ Si ya se alcanz√≥ el m√°ximo de intentos, romper el bucle
        if ($intentos -ge $MaxReintentos) {
            Write-WSLog "‚õî M√°ximo de intentos alcanzado, abortando conexi√≥n WebSocket." -Tipo Error
            Start-Sleep -Seconds $Config.TiempoReintento
            break
        }
            }
            
            Write-WSLog "‚ùå No se pudo conectar despu√©s de $MaxReintentos intentos" -Tipo Error
            $SharedState.WebSocketConnected = $false
            return $null
        }
        
        function Start-WSListener {
            param($WsClient)
            
            Write-WSLog "üëÇ Iniciando escucha continua de mensajes..." -Tipo Success
            $buffer = New-Object Byte[] 8192
            
            while ($WsClient.State -eq [System.Net.WebSockets.WebSocketState]::Open -and $SharedState.SessionActive) {
                try {
                    # Procesar cola de mensajes salientes (si existen)
                    try {
                        while ($SharedState.ContainsKey('OutgoingQueue') -and $SharedState.OutgoingQueue.Count -gt 0) {
                            $out = $SharedState.OutgoingQueue.Dequeue()
                            Send-WSMessage -WsClient $WsClient -Payload $out | Out-Null
                        }
                    }
                    catch { }
                    $result = $WsClient.ReceiveAsync([ArraySegment[byte]]$buffer, [Threading.CancellationToken]::None).Result
                    
                    if ($result.Count -gt 0) {
                        $mensaje = [System.Text.Encoding]::UTF8.GetString($buffer, 0, $result.Count)
                        Write-WSLog "üì© Recibido: $mensaje" -Tipo Info
                        
                        try {
                            $data = $mensaje | ConvertFrom-Json
                            
                            # Validar origen
                            if ($data.origen -ne "server") {
                                Write-WSLog "‚õî Origen no autorizado: $($data.origen)" -Tipo Warning
                                continue
                            }
                            
                            # Responder a pings inmediatamente (DENTRO DEL RUNSPACE)
                            if ($data.tipo -eq "ping") {
                                Send-WSMessage -WsClient $WsClient -Payload @{
                                    tipo = "pong"
                                    id = $Config.IdEquipo
                                    timestamp = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
                                } | Out-Null
                                Write-WSLog "üèì Pong enviado" -Tipo Info
                                continue
                            }
                            
                            # Encolar comando para procesamiento
                            $SharedState.CommandQueue.Enqueue($data)
                            $SharedState.LastMessage = $mensaje
                            
                            Write-WSLog "‚úÖ Encolado: $($data.tipo) - $($data.accion)" -Tipo Success
                        }
                        catch {
                            Write-WSLog "‚ö†Ô∏è Error JSON: $_" -Tipo Warning
                        }
                    }
                }
                catch {
                    Write-WSLog "‚ùå Error escucha: $_" -Tipo Error
                    break
                }
                
                Start-Sleep -Milliseconds 100
            }
            
            Write-WSLog "‚ö†Ô∏è Listener finalizado. Estado: $($WsClient.State)" -Tipo Warning
        }
        
        # ===== BUCLE PRINCIPAL DEL PROCESO WEBSOCKET =====
        Write-WSLog "üöÄ Proceso WebSocket iniciado" -Tipo Success
        
        while ($SharedState.SessionActive) {
            $ws = Connect-WSClient -MaxReintentos 5
            
            if ($ws) {
                Start-WSListener -WsClient $ws
                
                # Cerrar limpiamente
                try {
                    if ($ws.State -eq [System.Net.WebSockets.WebSocketState]::Open) {
                        $ws.CloseAsync('NormalClosure', 'Reconexi√≥n', [Threading.CancellationToken]::None).Wait(2000)
                    }
                    $ws.Dispose()
                }
                catch {
                    Write-WSLog "‚ö†Ô∏è Error al cerrar: $_" -Tipo Warning
                }
                
                $SharedState.WebSocketConnected = $false
                $SharedState.WSClientReference = $null
            }
            
            if ($SharedState.SessionActive) {
                Write-WSLog "üîÑ Reintentando en 5 segundos..." -Tipo Warning
                Start-Sleep -Seconds 5
            }
        }
        
        Write-WSLog "üõë Proceso WebSocket finalizado" -Tipo Info
    }
    
    # Ejecutar de forma as√≠ncrona
    $Global:WebSocketPowerShell.AddScript($wsScript) | Out-Null
    $Global:WebSocketPowerShell.BeginInvoke() | Out-Null
    
    Write-Log "‚úÖ Proceso WebSocket iniciado en runspace independiente" -Tipo Success
}

function Stop-WebSocketProcess {
    Write-Log "üõë Deteniendo proceso WebSocket..." -Tipo Warning
    
    $Global:SharedState.SessionActive = $false
    Start-Sleep -Seconds 2
    
    if ($Global:WebSocketPowerShell) {
        try {
            $Global:WebSocketPowerShell.Stop()
            $Global:WebSocketPowerShell.Dispose()
        }
        catch { }
    }
    
    if ($Global:WebSocketRunspace) {
        try {
            $Global:WebSocketRunspace.Close()
            $Global:WebSocketRunspace.Dispose()
        }
        catch { }
    }
    
    Write-Log "‚úÖ Proceso WebSocket detenido" -Tipo Success
}

# ============================================================
# üéÆ PROCESADOR DE COMANDOS WEBSOCKET
# ============================================================

function Invoke-AccionControl {
    param(
        [string]$Accion,
        [hashtable]$Detalles = @{}
    )
    
    Write-Log "üéØ Ejecutando acci√≥n: $Accion" -Tipo Info
    
    # Funci√≥n para enviar confirmaci√≥n
    function Send-Confirmacion {
        param([string]$Resultado, [string]$Mensaje)
        
        $payload = @{
            tipo = "confirmacion"
            origen = "equipo"
            usuario = $env:USERNAME
            mac_eq = $Global:SharedState.MacAddress
            nombre_eq = $Global:Config.IdEquipo
            accion = $Accion
            resultado = $Resultado
            mensaje = $Mensaje
            timestamp = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
        }
        
        if ($Detalles.corr) {
            $payload.corr = $Detalles.corr
        }
        
        # Intentar enviar por WebSocket si est√° disponible
        try {
            $wsClient = $Global:SharedState.WSClientReference
            
            if ($wsClient -and $wsClient.State -eq [System.Net.WebSockets.WebSocketState]::Open) {
                Enqueue-WSMessage -Payload $payload | Out-Null
                Write-Log "‚úÖ Confirmaci√≥n encolada para env√≠o" -Tipo Success
            }
            else {
                Write-Log "‚ö†Ô∏è WebSocket no disponible para encolar confirmaci√≥n" -Tipo Warning
            }
        }
        catch {
            Write-Log "‚ö†Ô∏è Error al enviar confirmaci√≥n: $_" -Tipo Warning
        }
    }
    
    switch ($Accion) {
        "bloquear" {
            Write-Log "üîí Bloqueando sesion..." -Tipo Warning
            $apiResp = Invoke-ApiCall -ExtraBody @{ accion = 'bloquear'; corr = $Detalles.corr }
            Send-Confirmacion -Resultado "ejecutando" -Mensaje "Bloqueando equipo..."
            Start-Sleep -Milliseconds 500
            
            try {
                Write-Log "üîí" -Tipo Warning
                #shutdown /l /f
                Send-Confirmacion -Resultado "ejecutado" -Mensaje "Equipo bloqueado exitosamente"
            }
            catch {
                Send-Confirmacion -Resultado "error" -Mensaje "Error al bloquear: $_"
            }
        }
        
        "suspender" {
            Write-Log "üí§ Suspendiendo equipo..." -Tipo Warning
            $apiResp = Invoke-ApiCall -ExtraBody @{ accion = 'suspender'; corr = $Detalles.corr }
            Send-Confirmacion -Resultado "ejecutando" -Mensaje "Preparando suspensi√≥n..."
            
            try {
                [System.Windows.Forms.MessageBox]::Show(
                    "El equipo se suspender√° en 10 segundos.`n¬øDesea guardar su trabajo?",
                    "Suspensi√≥n Programada",
                    [System.Windows.Forms.MessageBoxButtons]::OK,
                    [System.Windows.Forms.MessageBoxIcon]::Warning
                ) | Out-Null
                
                Start-Sleep -Seconds 10
                Send-Confirmacion -Resultado "ejecutado" -Mensaje "Suspendiendo..."
            }
            catch {
                Send-Confirmacion -Resultado "error" -Mensaje "Error al suspender: $_"
            }
        }
        
"finalizar" {
    Write-Log "‚õî Iniciando flujo FINALIZAR (API -> UI -> CONFIRM)" -Tipo Info

    $apiResp = Invoke-ApiCall -ExtraBody @{ accion = 'finalizar'; corr = $Detalles.corr }

    if ($null -eq $apiResp -or $apiResp.estado -eq 'Error') {
        Write-Log "‚ùå API fallo al finalizar: $($apiResp.mensaje)" -Tipo Error
        Send-Confirmacion -Resultado "error" -Mensaje ("API error: " + ($apiResp.mensaje -as [string]))
        break
    }

    if ($apiResp.estado -match 'FINALIZADO' -or $apiResp.estado -match 'OK') {
        [System.Windows.Forms.MessageBox]::Show("Su sesi√≥n fue finalizada. Gracias.","Finalizado",[System.Windows.Forms.MessageBoxButtons]::OK,[System.Windows.Forms.MessageBoxIcon]::Information)

        Send-Confirmacion -Resultado "ejecutado" -Mensaje "Finalizado con check-in en FOLIO"
        Start-Sleep -Seconds 3
        #shutdown /l /f
    } else {
        Send-Confirmacion -Resultado "error" -Mensaje ("Respuesta API inesperada: " + ($apiResp.mensaje -as [string]))
    }
}

        
        "renovar" {
            Write-Log "‚ôªÔ∏è Sesi√≥n renovada" -Tipo Success
            $apiResp = Invoke-ApiCall -ExtraBody @{ accion = 'renovar'; corr = $Detalles.corr }
            Send-Confirmacion -Resultado "ejecutado" -Mensaje "Renovaci√≥n confirmada"
            
            try {
                [System.Windows.Forms.MessageBox]::Show(
                    "‚úÖ Su sesi√≥n ha sido renovada correctamente.",
                    "Renovaci√≥n Exitosa"
                ) | Out-Null
            }
            catch { }
        }
        
        "mensaje" {
            $texto = if ($Detalles.texto) { $Detalles.texto } else { "Mensaje del administrador" }
            Write-Log "üí¨ Mostrando mensaje {$texto}" -Tipo Info
            
            try {
                [System.Windows.Forms.MessageBox]::Show(
                    $texto,
                    "Notificaci√≥n del Sistema",
                    [System.Windows.Forms.MessageBoxButtons]::OK,
                    [System.Windows.Forms.MessageBoxIcon]::Information
                ) | Out-Null
                
                Send-Confirmacion -Resultado "ejecutado" -Mensaje "Mensaje mostrado"
            }
            catch {
                Send-Confirmacion -Resultado "error" -Mensaje "Error al mostrar mensaje"
            }
        }
        
        "ver_info" {
            Write-Log "üìä Recopilando informaci√≥n..." -Tipo Info
            
            try {
                $info = @{
                    usuario = $env:USERNAME
                    equipo = $env:COMPUTERNAME
                    ip = (Get-NetIPAddress -AddressFamily IPv4 | 
                          Where-Object {$_.InterfaceAlias -notmatch "Loopback"} | 
                          Select-Object -First 1).IPAddress
                    mac = $Global:SharedState.MacAddress
                    so = (Get-CimInstance Win32_OperatingSystem).Caption
                    memoria = [Math]::Round((Get-CimInstance Win32_ComputerSystem).TotalPhysicalMemory / 1GB, 2)
                    procesador = (Get-CimInstance Win32_Processor).Name
                }
                
                $wsClient = $Global:SharedState.WSClientReference
                if ($wsClient -and $wsClient.State -eq [System.Net.WebSockets.WebSocketState]::Open) {
                    $payload = @{ tipo = "info_respuesta"; id = $Global:Config.IdEquipo; datos = $info }
                    Enqueue-WSMessage -Payload $payload | Out-Null
                    Write-Log "‚úÖ Informaci√≥n encolada para env√≠o" -Tipo Success
                }
            }
            catch {
                Write-Log "‚ùå Error al recopilar info: $_" -Tipo Error
                Send-Confirmacion -Resultado "error" -Mensaje "Error al obtener informaci√≥n"
            }
        }
        
        default {
            Write-Log "‚ö†Ô∏è Acci√≥n desconocida: $Accion" -Tipo Warning
            Send-Confirmacion -Resultado "desconocida" -Mensaje "Acci√≥n no reconocida"
        }
    }
}

# Funci√≥n auxiliar para convertir PSCustomObject a Hashtable
function ConvertTo-Hashtable {
    param([Parameter(ValueFromPipeline)]$InputObject)
    
    process {
        if ($null -eq $InputObject) { return $null }
        
        if ($InputObject -is [System.Collections.IDictionary]) {
            return $InputObject
        }
        
        if ($InputObject -is [PSCustomObject]) {
            $hash = @{}
            $InputObject.PSObject.Properties | ForEach-Object {
                $hash[$_.Name] = if ($_.Value -is [PSCustomObject]) {
                    ConvertTo-Hashtable $_.Value
                } else {
                    $_.Value
                }
            }
            return $hash
        }
        
        return $InputObject
    }
}

# Monitor de cola de comandos (Timer en UI thread)
function Start-CommandQueueMonitor {
    $timer = New-Object System.Windows.Forms.Timer
    $timer.Interval = 300
    
    $timer.Add_Tick({
        try {
            while ($Global:SharedState.CommandQueue.Count -gt 0) {
                try {
                    $comando = $Global:SharedState.CommandQueue.Dequeue()
                    
                    # Convertir PSCustomObject a Hashtable si es necesario
                    if ($comando -is [PSCustomObject]) {
                        $comando = ConvertTo-Hashtable $comando
                    }
                    if($comando.tipo -eq "control_server"){
                    switch ($comando.manejo) {
                        "comandos"{
                            # Convertir comando completo a hashtable
                            $detalles = ConvertTo-Hashtable $comando
                            Invoke-AccionControl -Accion $comando.accion -Detalles $detalles
                        }
                        "mensaje" {
                         $detalles = ConvertTo-Hashtable $comando
                         Invoke-AccionControl -Accion "mensaje" -Detalles @{texto = $comando.texto}
                        }
                        "info" {
                            Invoke-AccionControl -Accion "ver_info" -Detalles @{}
                        }
                        default {
                            Write-Log "‚ö†Ô∏è Comando desconocido: $($comando.tipo)" -Tipo Warning
                        }
                    }
                }
                }
                catch {
                    Write-Log "‚ùå Error procesando comando: $_" -Tipo Error
                }
            }
        }
        catch {
            # Silenciar errores del timer
        }
    })
    
    $timer.Start()
    return $timer
}

# ============================================================
# üåê API REST
# ============================================================

function Invoke-ApiCall {
    param([hashtable]$ExtraBody = @{})
    
    $body = @{
        username = $Global:Config.Username
        mac_address = $Global:SharedState.MacAddress
        origen = "equipo"
        tipo = "control"
    } + $ExtraBody
    
    $json = $body | ConvertTo-Json -Compress
    $headers = @{ "Content-Type" = "application/json" }
    
    try {
        $response = Invoke-RestMethod `
            -Uri $Global:Config.ApiUrl `
            -Method Post `
            -Headers $headers `
            -Body $json `
            -TimeoutSec 60
        
        return $response
    }
    catch {
        Write-Log "Error API: $($_.Exception.Message)" -Tipo Error
        return @{ estado = "Error"; mensaje = $_.Exception.Message }
    }
    if ($response.estado -eq "Error") {
    Write-Log "‚õî API no disponible, reintentando..." -Tipo Warning
    Start-Sleep -Seconds 5
    continue
}
}

# ============================================================
# üñ•Ô∏è INTERFAZ GR√ÅFICA
# ============================================================

function New-SessionForm {
    $form = New-Object System.Windows.Forms.Form
    $form.Text = "Gesti√≥n de Sesi√≥n - AutoPr√©stamos"
    $form.Size = [System.Drawing.Size]::new(400, 200)
    $form.StartPosition = "Manual"
    $form.FormBorderStyle = [System.Windows.Forms.FormBorderStyle]::FixedDialog
    $form.ShowInTaskbar = $false
    $form.MinimizeBox = $true
    $form.MaximizeBox = $false
    
    $form.Location = [System.Drawing.Point]::new(
        [System.Windows.Forms.Screen]::PrimaryScreen.WorkingArea.Width - 400,
        [System.Windows.Forms.Screen]::PrimaryScreen.WorkingArea.Height - 250
    )
    
    # Logo
    $logo = New-Object System.Windows.Forms.PictureBox
    $logo.SizeMode = "StretchImage"
    $logo.Size = [System.Drawing.Size]::new(80, 80)
    $logo.Location = [System.Drawing.Point]::new(10, 10)
    
    if (Test-Path $Global:Config.LogoPath) {
        try { 
            $logo.Image = [System.Drawing.Image]::FromFile($Global:Config.LogoPath) 
        }
        catch { }
    }
    $form.Controls.Add($logo)
    
    # Label Info
    $labelInfo = New-Object System.Windows.Forms.Label
    $labelInfo.Font = New-Object System.Drawing.Font("Segoe UI", 12)
    $labelInfo.Location = [System.Drawing.Point]::new(100, 10)
    $labelInfo.AutoSize = $true
    $labelInfo.Text = "Usuario: $($Global:Config.Username)`nMAC: $($Global:SharedState.MacAddress)"
    $form.Controls.Add($labelInfo)
    
    # Label Timer
    $labelTimer = New-Object System.Windows.Forms.Label
    $labelTimer.Font = New-Object System.Drawing.Font("Segoe UI", 14, [System.Drawing.FontStyle]::Bold)
    $labelTimer.Location = [System.Drawing.Point]::new(30, 100)
    $labelTimer.AutoSize = $true
    $labelTimer.Text = "Inicializando..."
    $form.Controls.Add($labelTimer)
        
    # Bot√≥n Minimizar
    $btnReducir = New-Object System.Windows.Forms.Button
    $btnReducir.Text = "Minimizar"
    $btnReducir.Size = [System.Drawing.Size]::new(80, 28)
    $btnReducir.Location = [System.Drawing.Point]::new($form.Width - 100, $form.Height - 68)
    $btnReducir.Add_Click({
        try {
            if ($form.Height -gt 120) {
                $form.Size = [System.Drawing.Size]::new(280, 100)
                $logo.Size = [System.Drawing.Size]::new(170, 60)
                $btnReducir.Text = "Maximizar"
            } else {
                $form.Size = [System.Drawing.Size]::new(400, 200)
                $logo.Size = [System.Drawing.Size]::new(80, 80)
                $btnReducir.Text = "Minimizar"
            }
            $form.Refresh()
        }
        catch { }
    })
    $form.Controls.Add($btnReducir)
    
    # ========================================
    # üñ±Ô∏è DETECTAR ACTIVIDAD DE USUARIO
    # ========================================
    # Cuando hay movimiento del rat√≥n, actualizar LastActivity
    $form.Add_MouseMove({
        param($sender, $e)
        $Global:SharedState.LastActivity = Get-Date
    })
    
    # Cuando se presiona una tecla, actualizar LastActivity
    $form.Add_KeyDown({
        param($sender, $e)
        $Global:SharedState.LastActivity = Get-Date
    })
    
    # Cuando el usuario hace click, actualizar LastActivity
    $form.Add_MouseDown({
        param($sender, $e)
        $Global:SharedState.LastActivity = Get-Date
    })
    
    return @{
        Form = $form
        LabelInfo = $labelInfo
        LabelTimer = $labelTimer
        Logo = $logo
        BtnReducir = $btnReducir
    }
}

# ============================================================
# üéÆ ESTADOS DE SESI√ìN
# ============================================================

function Invoke-EstadoAbierto {
    param($Controles, $Response)
    
    Write-Log "Estado: ABIERTO" -Tipo Success
    
    try {
        Start-Process -FilePath "explorer.exe" -ErrorAction SilentlyContinue
    }
    catch { }
    
    try {
        $Controles.LabelTimer.ForeColor = [System.Drawing.Color]::DarkGreen
        $tiempo = if ($Response.tiempo_restante) { $Response.tiempo_restante } else { 90 }
        
        for ($i = $tiempo; $i -ge 0; $i--) {
            $Controles.LabelTimer.Text = "üü¢ SESI√ìN ACTIVA - Restante: $(Format-TimeSpan $i)"
            $Controles.Form.Refresh()
            
            $waitUntil = (Get-Date).AddSeconds(1)
            while ((Get-Date) -lt $waitUntil) {
                [System.Windows.Forms.Application]::DoEvents()
                Start-Sleep -Milliseconds 50
            }
        }
    }
    catch {
        Write-Log "Error en countdown: $_" -Tipo Warning
    }
    
    return Invoke-ApiCall
}

# ============================================================
# üéÆ OTROS ESTADOS DE SESI√ìN
# ============================================================

function Invoke-EstadoBloqueado {
    param($Controles, $Response)
    
    Write-Log "Estado: BLOQUEADO" -Tipo Error
    
    try {
        $Controles.LabelTimer.ForeColor = [System.Drawing.Color]::Red
        
        # Verificar check-in de FOLIO
        if ($Response.folioCheckin -and 
            $Response.folioCheckin.raw -and 
            $Response.folioCheckin.raw.loan.status.name -eq "Closed") {
            
            Write-Log "Check-in detectado, actualizando estado..." -Tipo Info
            Start-Sleep -Seconds 1
            return Invoke-ApiCall
        }
        
        $tiempo = if ($Response.tiempo_restante) { $Response.tiempo_restante } else { 10 }
        
        for ($i = $tiempo; $i -ge 0; $i--) {
            $Controles.LabelTimer.Text = "üîí BLOQUEADO - Restante: $(Format-TimeSpan $i)"
            $Controles.Form.Refresh()
            
            $waitUntil = (Get-Date).AddSeconds(1)
            while ((Get-Date) -lt $waitUntil) {
                [System.Windows.Forms.Application]::DoEvents()
                Start-Sleep -Milliseconds 50
            }
        }
    }
    catch {
        Write-Log "Error en countdown bloqueado: $_" -Tipo Warning
    }
    
    return Invoke-ApiCall
}

function Invoke-EstadoSuspendido {
    param($Controles, $Response)
    
    Write-Log "Estado: SUSPENDIDO" -Tipo Warning
    
    try {
        $Controles.LabelTimer.ForeColor = [System.Drawing.Color]::Orange
        $Controles.LabelTimer.Text = "‚è∏Ô∏è SESI√ìN SUSPENDIDA"
        $Controles.Form.Refresh()
        
        # Mostrar modal de desbloqueo (simplificado)
        $resultado = [System.Windows.Forms.MessageBox]::Show(
            "Sesi√≥n suspendida. Ingrese OK para desbloquear con clave admin.",
            "Sesi√≥n Suspendida",
            [System.Windows.Forms.MessageBoxButtons]::OKCancel,
            [System.Windows.Forms.MessageBoxIcon]::Warning
        )
        
        if ($resultado -eq [System.Windows.Forms.DialogResult]::OK) {
            return Invoke-ApiCall -ExtraBody @{ clave_admin = $Global:Config.ClaveAdmin }
        }
        else {
            return Invoke-ApiCall -ExtraBody @{ cancel_suspend = "Cancelar" }
        }
    }
    catch {
        Write-Log "Error en estado suspendido: $_" -Tipo Error
        return Invoke-ApiCall
    }
}
<#
.SYNOPSIS
    Procesa el estado "Restringido" (bloqueos FOLIO)
#>
function Invoke-EstadoRestringido {
    param(
        [Parameter(Mandatory=$true)]$Controles,
        [Parameter(Mandatory=$true)]$Response
    )
    
    Write-Log "Estado: RESTRINGIDO - Usuario con bloqueos en FOLIO" -Tipo Error
    
    # Redimensionar ventana
    $Controles.Form.Location = [System.Drawing.Point]::new(
        [System.Windows.Forms.Screen]::PrimaryScreen.WorkingArea.Width - 1400,
        [System.Windows.Forms.Screen]::PrimaryScreen.WorkingArea.Height - 800
    )
    $Controles.Form.Size = [System.Drawing.Size]::new(900, 500)
    
    # Actualizar t√≠tulo
    $Controles.LabelInfo.ForeColor = [System.Drawing.Color]::Red
    $Controles.LabelInfo.Font = New-Object System.Drawing.Font("Segoe UI", 16, [System.Drawing.FontStyle]::Bold)
    $Controles.LabelInfo.Text = "üö´ ACCESO RESTRINGIDO: Usuario bloqueado en FOLIO"
    $Controles.LabelInfo.Location = [System.Drawing.Point]::new(50, 20)
    
    # Crear cuadro de texto para mostrar bloqueos
    $txtBloqueos = New-Object System.Windows.Forms.TextBox
    $txtBloqueos.Multiline = $true
    $txtBloqueos.ScrollBars = "Vertical"
    $txtBloqueos.Font = New-Object System.Drawing.Font("Consolas", 12)
    $txtBloqueos.ReadOnly = $true
    $txtBloqueos.BackColor = [System.Drawing.Color]::White
    $txtBloqueos.Size = [System.Drawing.Size]::new(850, 350)
    $txtBloqueos.Location = [System.Drawing.Point]::new(20, 100)
    $Controles.Form.Controls.Add($txtBloqueos)
    
    # Formatear bloqueos manuales
    if ($Response.bloqueos.manuales) {
        $detalles = foreach ($m in $Response.bloqueos.manuales) {
            "üìå BLOQUEO MANUAL`r`n" +
            "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`r`n" +
            "Tipo: $($m.type)`r`n" +
            "Descripci√≥n: $($m.desc)`r`n" +
            "Mensaje al usuario: $($m.patronMessage)`r`n" +
            "Fecha de expiraci√≥n: $(Convert-ToColombiaDate $m.expirationDate)`r`n" +
            "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`r`n`r`n"
        }
        $txtBloqueos.Text = ($detalles -join "`r`n")
    }
    # Formatear bloqueos autom√°ticos
    elseif ($Response.bloqueos.automaticos) {
        $detalles = foreach ($a in $Response.bloqueos.automaticos) {
            "‚ö° BLOQUEO AUTOM√ÅTICO`r`n" +
            "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`r`n" +
            "Raz√≥n: $($a.message)`r`n" +
            "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`r`n`r`n"
        }
        $txtBloqueos.Text = ($detalles -join "`r`n")
    }
    
    # Actualizar bot√≥n cerrar con countdown
    $Controles.BtnReducir.Size = [System.Drawing.Size]::new(120, 40)
    $Controles.BtnReducir.Location = [System.Drawing.Point]::new(760, 420)
    $Controles.BtnReducir.Font = New-Object System.Drawing.Font("Segoe UI", 10, [System.Drawing.FontStyle]::Bold)
    
    # Timer de autocierre (6 segundos)
    $segundos = 6
    for ($i = $segundos; $i -ge 1; $i--) {
        Process-PendingMessages
        $Controles.BtnReducir.Text = "Cerrar ($i)"
        $Controles.Form.Refresh()
        
        $waitUntil = (Get-Date).AddSeconds(1)
        while ((Get-Date) -lt $waitUntil) {
            [System.Windows.Forms.Application]::DoEvents()
            Process-PendingMessages
            Start-Sleep -Milliseconds 50
        }
    }
    
    $Controles.Form.Close()
}

function Invoke-EstadoFinalizado {
    param(
        [Parameter(Mandatory=$true)]$Controles,
        [Parameter(Mandatory=$true)]$Response
    )
    
    Write-Log "Estado: FINALIZADO - Sesi√≥n completada" -Tipo Success
    
    # Actualizar interfaz
    $Controles.LabelInfo.ForeColor = [System.Drawing.Color]::Blue
    $Controles.LabelTimer.Text = "‚úÖ Sesi√≥n finalizada correctamente"
    $Controles.LabelTimer.ForeColor = [System.Drawing.Color]::Green
    $Controles.Form.Refresh()
    
    # Esperar 2 segundos antes de cerrar
    Start-Sleep -Seconds 2
    
    $Controles.Form.Close()
}

# ============================================================
# üí§ UI - Estado Hibernando
# ============================================================
function Invoke-EstadoHibernando {
    param(
        [Parameter(Mandatory)][hashtable]$Controles,
        [Parameter(Mandatory)][hashtable]$Response
    )

    Add-Type -AssemblyName PresentationFramework

    # ü™ü Configuraci√≥n de ventana bloqueante
    $window = New-Object System.Windows.Window
    $window.Title = "Modo Hibernaci√≥n"
    $window.WindowStartupLocation = "CenterScreen"
    $window.WindowState = "Maximized"
    $window.WindowStyle = "None"
    $window.ResizeMode = "NoResize"
    $window.Topmost = $true
    $window.Background = "#111111"
    $window.Foreground = "White"
    $window.Focusable = $true

    # üß± Layout
    $grid = New-Object System.Windows.Controls.Grid

    $labelMsg = New-Object System.Windows.Controls.TextBlock
    $labelMsg.Text = "üí§ El equipo entr√≥ en modo de hibernaci√≥n"
    $labelMsg.FontSize = 36
    $labelMsg.FontWeight = 'Bold'
    $labelMsg.HorizontalAlignment = "Center"
    $labelMsg.VerticalAlignment = "Center"
    $labelMsg.Margin = "0,0,0,100"

    $labelCountdown = New-Object System.Windows.Controls.TextBlock
    $labelCountdown.FontSize = 26
    $labelCountdown.Text = "Finalizando en 60 segundos..."
    $labelCountdown.HorizontalAlignment = "Center"
    $labelCountdown.VerticalAlignment = "Center"
    $labelCountdown.Margin = "0,100,0,0"

    $grid.Children.Add($labelMsg)
    $grid.Children.Add($labelCountdown)
    $window.Content = $grid

    # üß† Variables de control
    $segundosRestantes = 60
    $hibernando = $true
    $idlePrevio = Get-SystemIdleTime

    # ‚è±Ô∏è Temporizador del contador
    $timer = New-Object System.Windows.Threading.DispatcherTimer
    $timer.Interval = [TimeSpan]::FromSeconds(1)

    $timer.Add_Tick({
        try {
            $segundosRestantes--
            $labelCountdown.Text = "Finalizando en $segundosRestantes segundos..."
            
            $idleActual = Get-SystemIdleTime

            # üîì Detectar actividad global o combinaci√≥n Ctrl+1
            $actividadDetectada = $idleActual -lt 3 -or (
                [System.Windows.Input.Keyboard]::IsKeyDown('LeftCtrl') -and 
                [System.Windows.Input.Keyboard]::IsKeyDown('D1')
            )

if ($actividadDetectada) {
    Write-Log "üü¢ Actividad detectada ‚Äî cancelando hibernaci√≥n." -Tipo Info
    
    # üîÅ Registrar nueva actividad global
    $Global:SharedState.LastActivity = Get-Date

    $hibernando = $false
    $timer.Stop()
    $window.Close()
    
    # Reanudar sesi√≥n normal
    $script:Response = Invoke-EstadoRenovado -Controles $Controles -Response $Response
    return
}


            # ‚è≥ Si llega a 0 ‚Üí finalizar sesi√≥n
            if ($segundosRestantes -le 0) {
                Write-Log "‚è∞ Tiempo agotado ‚Äî finalizando sesi√≥n autom√°ticamente." -Tipo Warning
                $timer.Stop()
                $hibernando = $false
                $window.Close()
                Invoke-FinalizarSesionRemota
                return
            }

            $idlePrevio = $idleActual
        }
        catch {
            Write-Log "‚ùå Error en temporizador de hibernaci√≥n: $_" -Tipo Error
        }
    })

    $timer.Start()
    Write-Log "üò¥ Ventana de hibernaci√≥n mostrada (contador iniciado)" -Tipo Info
    $window.ShowDialog() | Out-Null

    if (-not $hibernando) {
        Write-Log "‚úÖ Hibernaci√≥n cancelada o finalizada correctamente." -Tipo Success
    }

    return $Response
}


# ============================================================
# üß© Funci√≥n auxiliar para cerrar sesi√≥n desde hibernaci√≥n
# ============================================================
function Invoke-FinalizarSesionRemota {
    try {
        Write-Host "[üîö] Finalizando sesi√≥n en servidor..."
        $payload = @{
            tipo = "comando_api"
            origen = "server"
            accion = "finalizar"
            username = $Global:Usuario
            mac_address = $Global:Mac
        }
        Invoke-RestMethod -Uri "http://localhost/autoprestamos/prueba_equipos/api.php" `
            -Method Post -Body ($payload | ConvertTo-Json) -ContentType "application/json" | Out-Null
        Write-Host "[‚úÖ] Sesi√≥n finalizada correctamente (hibernaci√≥n)."
    } catch {
        Write-Host "[‚ùå] Error al finalizar sesi√≥n remota: $_"
    }
}

function Invoke-EstadoRenovado {
    param (
        [hashtable]$Controles,
        [hashtable]$Response
    )

    Add-Type -AssemblyName PresentationFramework

    [System.Windows.MessageBox]::Show(
        "Tu sesi√≥n ha sido renovada exitosamente. ¬°Puedes continuar tu trabajo!",
        "Sesi√≥n Renovada",
        "OK",
        "Information"
    )

    return $Response
}

function Invoke-EstadoError {
    param($Controles, $Response)
    
    Write-Log "Estado: ERROR - $($Response.mensaje)" -Tipo Error
    
    try {
        [System.Windows.Forms.MessageBox]::Show(
            $Response.mensaje,
            "‚ùå Error de Sesi√≥n",
            [System.Windows.Forms.MessageBoxButtons]::OK,
            [System.Windows.Forms.MessageBoxIcon]::Error
        ) | Out-Null
        
        $Controles.Form.Close()
    }
    catch { }
}

# ============================================================
# üöÄ INICIALIZACI√ìN Y BUCLE PRINCIPAL
# ============================================================

function Start-SessionLoop {
    Write-Log "Iniciando bucle principal de sesi√≥n..." -Tipo Info
    
    try {
        $controles = New-SessionForm
        $response = Invoke-ApiCall -ExtraBody @{ confirmar_inicio = "true" }

        if (-not $response.estado) {
            Write-Log "No se pudo obtener estado inicial" -Tipo Error
            return
        }
        
        # üß© Iniciar monitor WebSocket (sin cambios)
        $queueMonitor = Start-CommandQueueMonitor

        $controles.Form.Show()

        # ‚öôÔ∏è Inicializaci√≥n de variables de inactividad
        $hibernando = $false
        $inicioHibernacion = $null

        while ($response -and 
               $response.estado -notin @("Finalizado", "Restringido", "Error")) {
            
            Write-Log "Estado actual: $($response.estado)" -Tipo Info

            try {
                # ============================================================
                # üîÅ Control global de inactividad del sistema
                # ============================================================
                $idle = Get-SystemIdleTime  # segundos de inactividad total (mouse/teclado)

                if (-not $hibernando -and $idle -ge $Global:SharedState.INACTIVITY_TIMEOUT) {
                    Write-Log "üò¥ Inactividad detectada ($idle s) ‚Üí Entrando en modo hibernaci√≥n" -Tipo Warning
                    $response = Invoke-EstadoHibernando -Controles $controles -Response $response
                    $hibernando = $true
                    $inicioHibernacion = Get-Date
                }
                elseif ($hibernando) {
                    if ($idle -lt 3) {
                        Write-Log "üü¢ Actividad detectada ‚Üí Cancelando hibernaci√≥n" -Tipo Info
                        $hibernando = $false
                        $inicioHibernacion = $null
                        $response = Invoke-EstadoRenovado -Controles $controles -Response $response
                    }
                    elseif ((New-TimeSpan -Start $inicioHibernacion -End (Get-Date)).TotalSeconds -ge 60) {
                        Write-Log "‚õî Inactividad prolongada (60s) ‚Üí Finalizando sesi√≥n autom√°ticamente" -Tipo Error
                        Invoke-FinalizarSesionRemota
                        break
                    }
                }

                # ============================================================
                # ‚ö° Procesamiento de estados normales (sin cambios)
                # ============================================================
                switch ($response.estado) {
                    "Abierto" {
                        $response = Invoke-EstadoAbierto -Controles $controles -Response $response
                    }
                    "Bloqueado" {
                        $response = Invoke-EstadoBloqueado -Controles $controles -Response $response
                    }
                    "Suspendido" {
                        $response = Invoke-EstadoSuspendido -Controles $controles -Response $response
                    }
                    "Renovado" {
                        $response = Invoke-EstadoRenovado -Controles $controles -Response $response
                    }
                    "Hibernando" {
                        $response = Invoke-EstadoHibernando -Controles $controles -Response $response
                    }
                    default {
                        if ($response.folioResp -and 
                            $response.folioResp.raw.loan.status.name -eq "Closed") {
                            Write-Log "Pr√©stamo cerrado en FOLIO" -Tipo Info
                            break
                        }
                        Write-Log "Estado desconocido: $($response.estado)" -Tipo Warning
                        Start-Sleep -Seconds 2
                        $response = Invoke-ApiCall
                    }
                }
            }
            catch {
                Write-Log "Error procesando estado: $_" -Tipo Error
                Start-Sleep -Seconds 2
                $response = Invoke-ApiCall
            }

            Start-Sleep -Milliseconds 200
        }
        
        # ============================================================
        # üßæ Procesar estados finales
        # ============================================================
        if ($response.estado -eq "Finalizado") {
            Invoke-EstadoFinalizado -Controles $controles -Response $response
        }
        elseif ($response.estado -eq "Restringido") {
            Invoke-EstadoRestringido -Controles $controles -Response $response
        }
        elseif ($response.estado -eq "Error") {
            Invoke-EstadoError -Controles $controles -Response $response
        }

        # ============================================================
        # üßπ Limpieza final
        # ============================================================
        try {
            $queueMonitor.Stop()
            $queueMonitor.Dispose()
            $controles.WSTimer.Stop()
            $controles.WSTimer.Dispose()
            $controles.Form.Close()
            $controles.Form.Dispose()
        }
        catch { }

        Write-Log "Bucle de sesi√≥n finalizado" -Tipo Success
    }
    catch {
        Write-Log "Error cr√≠tico en bucle de sesi√≥n: $_" -Tipo Error
    }
}

function Initialize-System {
    Write-Log "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -Tipo Info
    Write-Log "  SISTEMA DE AUTOPR√âSTAMOS - UNIVERSIDAD SIM√ìN BOL√çVAR" -Tipo Info
    Write-Log "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -Tipo Info
    
    # Detectar interfaz de red
    Write-Log "Detectando configuraci√≥n de red..." -Tipo Info
    $networkInfo = Get-ActiveNetworkInterface
    
    if (-not $networkInfo) {
        Write-Log "No se pudo detectar la red. Abortando..." -Tipo Error
        return $false
    }
    
    $Global:SharedState.MacAddress = $networkInfo.MAC
    
    # Verificar logo
    if (-not (Test-Path $Global:Config.LogoPath)) {
        Write-Log "Logo no encontrado (se continuar√° sin logo)" -Tipo Warning
    }
    
    # Conectar WebSocket
    Write-Log "Estableciendo conexi√≥n WebSocket..." -Tipo Info
    Start-WebSocketProcess
    
    Write-Log "‚è≥ Esperando inicializaci√≥n de WebSocket (3 seg)..." -Tipo Info
    Start-Sleep -Seconds 3
    
    if ($Global:SharedState.WebSocketConnected) {
        Write-Log "‚úÖ WebSocket conectado" -Tipo Success
    }
    else {
        Write-Log "‚ö†Ô∏è WebSocket no conectado (funcionar√° en modo degradado)" -Tipo Warning
    }
    
    Write-Log "‚úÖ Inicializaci√≥n completada" -Tipo Success
    return $true
}

function Clear-Resources {
    Write-Log "üßπ Limpiando recursos..." -Tipo Info
    
    try {
        Stop-WebSocketProcess
    }
    catch {
        Write-Log "‚ö†Ô∏è Error al detener WebSocket: $_" -Tipo Warning
    }

    # üß© Cierre limpio de runspace y objetos PowerShell
    try {
        if ($Global:WebSocketPowerShell) {
            $Global:WebSocketPowerShell.Dispose()
            Write-Log "üß† WebSocket PowerShell liberado" -Tipo Info
        }
    } catch {
        Write-Log "‚ö†Ô∏è Error al liberar PowerShell: $_" -Tipo Warning
    }

    try {
        if ($Global:WebSocketRunspace) {
            $Global:WebSocketRunspace.Dispose()
            Write-Log "üß† Runspace liberado" -Tipo Info
        }
    } catch {
        Write-Log "‚ö†Ô∏è Error al liberar runspace: $_" -Tipo Warning
    }
    
    Write-Log "‚úÖ Recursos liberados completamente" -Tipo Success
}


# ============================================================
# üé¨ PUNTO DE ENTRADA PRINCIPAL
# ============================================================

try {
    Clear-Host
    Write-Host ""
    Write-Host "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Cyan
    Write-Host "‚ïë                                                      ‚ïë" -ForegroundColor Cyan
    Write-Host "‚ïë    SISTEMA DE AUTOPR√âSTAMOS - UNISIM√ìN              ‚ïë" -ForegroundColor Cyan
    Write-Host "‚ïë    v2.2 - Arquitectura Dual Process                 ‚ïë" -ForegroundColor Cyan
    Write-Host "‚ïë    (Depuraci√≥n Completa)                            ‚ïë" -ForegroundColor Cyan
    Write-Host "‚ïë                                                      ‚ïë" -ForegroundColor Cyan
    Write-Host "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Cyan
    Write-Host ""
    
    # Inicializar sistema
    $initialized = Initialize-System
    
    if (-not $initialized) {
        Write-Log "Fallo en la inicializaci√≥n. Abortando..." -Tipo Error
        exit 1
    }
    
    # Ejecutar bucle de sesi√≥n
    Start-SessionLoop
    
    Write-Log "‚úÖ Ejecuci√≥n completada exitosamente" -Tipo Success
}
catch {
    Write-Log "‚ùå Error cr√≠tico: $($_.Exception.Message)" -Tipo Error
    Write-Log "Stack Trace: $($_.ScriptStackTrace)" -Tipo Error
}
# ============================================================
# FIN DEL SCRIPT - v2.2
# ============================================================
# =============================================
# üß© CLIENTE AUTOPR√âSTAMOS - UNISIM√ìN (PowerShell)
# Comunicaci√≥n WebSocket + API + Control local
# Autor: Sistema Autopr√©stamos
# Versi√≥n: 1.6 (clean) - 24-Oct-2025
# =============================================

Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing

# -------------------------
# CONFIGURACI√ìN
# -------------------------
$ServidorWS = "ws://localhost:8081"
$idEquipo   = $env:COMPUTERNAME
$uri        = [System.Uri]$ServidorWS
$global:wsClient = $null

# Valores por defecto (puedes sobrescribir al llamar a Show-VentanaSesion)
$DefaultLogoPath = "C:\xampp\htdocs\autoprestamos\prueba_equipos\logo.png"
$DefaultApiUrl   = "http://localhost/autoprestamos/prueba_equipos/api.php"
$DefaultClaveAdmin = "S1m0n_2025"

# -------------------------
# LOG SIMPLE
# -------------------------
function Log {
    param([string]$msg)
    Write-Host "[LOG $(Get-Date -Format 'HH:mm:ss')] $msg"
}

# -------------------------
# COMPROBAR ESTADO DEL SERVIDOR (HTTP)
# -------------------------
function Test-ServidorActivo {
    try {
        $resp = Invoke-WebRequest -Uri "http://localhost/autoprestamos/servers/estado_server.php" -UseBasicParsing -TimeoutSec 3
        $json = $resp.Content | ConvertFrom-Json
        return $json.status -eq "corriendo"
    } catch {
        return $false
    }
}
function Reiniciar-TiempoSesion {
    Log "üîÅ Reiniciando tiempo de sesi√≥n..."
    # Aqu√≠ puedes resetear tu temporizador actual
    $global:TiempoRestante = 180 # ejemplo: 3 minutos
}
# -------------------------
# REGISTRAR CLIENTE (env√≠a un JSON inicial al servidor WS)
# -------------------------
function Registrar-Cliente {
    param($ws)
    $msgJson = @{
        accion = "UpdateStatus"
        id     = $env:COMPUTERNAME
    } | ConvertTo-Json -Compress

    $msgBytes = [System.Text.Encoding]::UTF8.GetBytes($msgJson)
    $segment  = [System.ArraySegment[byte]]::new($msgBytes)

    try {
        $ws.SendAsync($segment, [System.Net.WebSockets.WebSocketMessageType]::Text, $true, [Threading.CancellationToken]::None).Wait()
        Log "üì° Cliente registrado ‚Üí ID: $idEquipo"
    } catch {
        Log "‚ùå Error al registrar cliente: $($_.Exception.Message)"
    }
}

# -------------------------
# ESCUCHAR MENSAJES (actualizado)
# -------------------------
function Escuchar-WebSocket {
    param([System.Net.WebSockets.ClientWebSocket]$wsClient)
    $buffer = New-Object Byte[] 4096

    while ($wsClient.State -eq [System.Net.WebSockets.WebSocketState]::Open) {
        try {
            $result = $wsClient.ReceiveAsync([ArraySegment[byte]]$buffer, [Threading.CancellationToken]::None).Result
if ($result -and $result.Count -gt 0) {
    $msg = [System.Text.Encoding]::UTF8.GetString($buffer, 0, $result.Count)
    
    # üí¨ Mostrar siempre el JSON que llega (para depuraci√≥n)
    Write-Host ""
    Write-Host "=========================================" -ForegroundColor Cyan
    Write-Host "üì° JSON recibido del Dashboard:" -ForegroundColor Yellow
    Write-Host $msg -ForegroundColor White
    Write-Host "=========================================" -ForegroundColor Cyan
    Write-Host ""

    try {
        $data = $msg | ConvertFrom-Json -ErrorAction Stop 
    } catch {
        Log "‚ö†Ô∏è No se pudo convertir el mensaje a JSON: $($_.Exception.Message)"
        $data = $null
    }

                $accion = $data.accion
                if (-not $accion) { $accion = $data.comando }
                if (-not $accion) { continue }

                switch ($accion) {
                    'mensaje' {
                        [System.Windows.Forms.MessageBox]::Show($data.mensaje, "Administrador")
                        Log "üí¨ Mensaje mostrado al usuario."
                        $ackMsg = "Mensaje mostrado con √©xito"
                    }
                    'suspender' {
                        Log "‚ö†Ô∏è Suspender sesi√≥n recibido"
                        Start-Process "shutdown.exe" -ArgumentList "/h"
                        $ackMsg = "Acci√≥n 'suspender' ejecutada"
                    }
                    'finalizar' {
                        Log "üö™ Finalizar sesi√≥n recibido"
                        shutdown.exe /l
                        $ackMsg = "Acci√≥n 'finalizar' ejecutada"
                    }
                    'bloquear' {
                        Log "üîí Bloquear sesi√≥n recibido"
                        rundll32.exe user32.dll,LockWorkStation
                        $ackMsg = "Acci√≥n 'bloquear' ejecutada"
                    }
                    'renovar' {
                        Log "‚è±Ô∏è Renovar sesi√≥n recibido"
                        Reiniciar-TiempoSesion
                        $ackMsg = "Acci√≥n 'renovar' ejecutada"
                    }
                    default {
                        Log "‚öôÔ∏è Comando desconocido: $accion"
                        $ackMsg = "Comando desconocido: $accion"
                    }
                }

                # --- Enviar ACK al servidor ---
                if ($ackMsg) {
                    $ack = @{
                        tipo    = "log"
                        id      = $env:COMPUTERNAME
                        mensaje = $ackMsg
                    } | ConvertTo-Json -Compress

                    try {
                        $bytes = [System.Text.Encoding]::UTF8.GetBytes($ack)
                        $wsClient.SendAsync([ArraySegment[byte]]$bytes,
                            [System.Net.WebSockets.WebSocketMessageType]::Text,
                            $true,
                            [Threading.CancellationToken]::None).Wait()
                        Log "üì§ ACK enviado: $ackMsg"
                    } catch {
                        Log "‚ö†Ô∏è Error enviando ACK: $($_.Exception.Message)"
                    }
                }
            }
        } catch {
            Log "‚ö†Ô∏è Error en la escucha WS: $($_.Exception.Message)"
            break
        }
        Start-Sleep -Milliseconds 200
    }

    Log "üî¥ Conexi√≥n WebSocket cerrada (escucha finalizada)."
    if (Test-ServidorActivo) {
        Log "üîÅ Intentando reconexi√≥n autom√°tica..."
        Conectar-WebSocket -MaxReintentos 3 | Out-Null
    } else {
        Log "‚õî Servidor no disponible. Reconexi√≥n cancelada."
    }
}

# -------------------------
# CONEXI√ìN CON RETRY (usa Test-ServidorActivo)
# -------------------------
function Conectar-WebSocket {
    param([int]$MaxReintentos = 5)
    $intentos = 0

    while ($intentos -le $MaxReintentos) {
        if (-not (Test-ServidorActivo)) {
            Log "‚ö†Ô∏è Servidor WebSocket no disponible. No se intentar√° reconectar."
            return $false
        }
        try {
            Log "üîå Intentando conectar a $ServidorWS ..."
            $global:wsClient = [System.Net.WebSockets.ClientWebSocket]::new()
            $global:wsClient.ConnectAsync($uri, [Threading.CancellationToken]::None).Wait()

            if ($global:wsClient.State -eq [System.Net.WebSockets.WebSocketState]::Open) {
                Log "‚úÖ Conectado al servidor WebSocket como $idEquipo"
                Registrar-Cliente -ws $global:wsClient
                # Lanza el listener en segundo plano con acceso al socket real
Start-Job -Name "EscuchaWebSocket" -ScriptBlock {
    param($ws)
    # Importa las funciones del contexto actual (incluyendo Escuchar-WebSocket)
    . $MyInvocation.MyCommand.Path
    Escuchar-WebSocket -wsClient $ws
} -ArgumentList $global:wsClient | Out-Null

                return $true
            }
        } catch {
            Log "‚ùå Error de conexi√≥n: $($_.Exception.Message)"
        }

        $intentos++
        if ($intentos -le $MaxReintentos) {
            Start-Sleep -Seconds 1
            Log "‚è≥ Reintentando conexi√≥n ($intentos/$MaxReintentos)..."
            Start-Sleep -Seconds 2
        } else {
            Log "‚ùå Se alcanz√≥ el l√≠mite de reintentos ($MaxReintentos)."
            return $false
        }
    }
}

# -------------------------
# PING PERI√ìDICO PARA DETECTAR CA√çDAS Y TRIGGEAR RECONEXI√ìN
# -------------------------
Start-Job -Name "PingServidor" -ScriptBlock {
    while ($true) {
        try {
            $alive = Test-Connection -ComputerName "localhost" -Count 1 -Quiet -ErrorAction SilentlyContinue
            if (-not $alive) {
                Write-Host "[PING $(Get-Date -Format 'HH:mm:ss')] ‚ö†Ô∏è No respuesta del servidor. Intentando revalidar..."
                if (Test-ServidorActivo) {
                    Conectar-WebSocket -MaxReintentos 2 | Out-Null
                }
            }
        } catch { }
        Start-Sleep -Seconds 30
    }
} | Out-Null

# -------------------------
# UTILIDADES (Fecha, Formateo, API)
# -------------------------
function Format-Time([int]$segundos) {
    $ts = [TimeSpan]::FromSeconds($segundos)
    return "{0:00}:{1:00}:{2:00}" -f $ts.Hours, $ts.Minutes, $ts.Seconds
}

function Convert-ToColombiaDate {
    param([string]$utcString)
    try {
        $dtUtc = [System.Xml.XmlConvert]::ToDateTime($utcString, [System.Xml.XmlDateTimeSerializationMode]::Utc)
        $tzCol = [System.TimeZoneInfo]::FindSystemTimeZoneById("SA Pacific Standard Time")
        $dtCol = [System.TimeZoneInfo]::ConvertTimeFromUtc($dtUtc, $tzCol)
        return $dtCol.ToString("dddd, dd 'de' MMMM 'de' yyyy", [System.Globalization.CultureInfo]::GetCultureInfo("es-CO"))
    } catch {
        return $utcString
    }
}

function Call-Api {
    param([hashtable]$extraBody = @{})
    $body = @{ username = $Username; mac_address = $mac } + $extraBody
    $json = $body | ConvertTo-Json -Compress
    $headers = @{ "Content-Type" = "application/json" }
    try {
        $resp = Invoke-RestMethod -Uri $ApiUrl -Method Post -Headers $headers -Body $json -TimeoutSec 60
        Log ("? Respuesta API: " + ($resp | ConvertTo-Json -Compress))
        return $resp
    }
    catch [System.Net.WebException] {
        $errorMsg = "? Error de conexi√≥n con la API: $($_.Exception.Message)"
        Log $errorMsg
        return @{ estado="Error"; mensaje=$errorMsg }
    }
    catch {
        $errorMsg = "?? Error inesperado: $($_.Exception.Message)"
        Log $errorMsg
        return @{ estado="Error"; mensaje=$errorMsg }
    }
}

# -------------------------
# DETECCI√ìN INTERFAZ & VARIABLES USUARIO
# -------------------------
# detectar interfaz activa para MAC y uso en Call-Api
$interfazActiva = Get-NetIPConfiguration |
    Where-Object { $_.IPv4DefaultGateway -ne $null -and $_.NetAdapter.Status -eq "Up" } |
    Select-Object -First 1

if ($interfazActiva) {
    $mac = $interfazActiva.NetAdapter.MacAddress.Replace("-", ":")
    $nombre = $interfazActiva.NetAdapter.InterfaceAlias
    Log "‚úÖ Interfaz activa: $nombre - MAC: $mac"
} else {
    $mac = "unknown"
    Log "‚ùå No se encontr√≥ interfaz con gateway activo."
}

$Username = $env:USERNAME
$ApiUrl   = $DefaultApiUrl
$LogoPath = $DefaultLogoPath

# -------------------------
# INICIAR CONEXI√ìN WEBSOCKET (al arrancar el script)
# -------------------------
Conectar-WebSocket -MaxReintentos 3 | Out-Null

# -------------------------
# FUNCION PRINCIPAL UI - Show-VentanaSesion
# (definida despu√©s de las utilidades y red)
# -------------------------
function Show-VentanaSesion {
    param (
        [string]$Titulo = "Gestion de Seccion",
        [string]$ClaveAdmin = $DefaultClaveAdmin,
        [string]$LogoPathParam = $LogoPath,
        [string]$ApiUrlParam   = $ApiUrl
    )

    # variables locales
    $global:ApiUrl = $ApiUrlParam
    $global:LogoPath = $LogoPathParam

    # Form principal
    $form = New-Object System.Windows.Forms.Form
    $form.Text = $Titulo
    $form.Size = [System.Drawing.Size]::new(400,200)
    $form.StartPosition = "Manual"
    $form.FormBorderStyle = [System.Windows.Forms.FormBorderStyle]::FixedDialog
    $form.ShowInTaskbar = $false
    $form.MinimizeBox = $true
    $form.MaximizeBox = $false
    $form.ControlBox = $true
    $form.Location = [System.Drawing.Point]::new(
        [System.Windows.Forms.Screen]::PrimaryScreen.WorkingArea.Width - 400,
        [System.Windows.Forms.Screen]::PrimaryScreen.WorkingArea.Height - 250
    )

    # Manejo cierre: intentar cerrar ws cleanly
    $form.Add_FormClosing({
        if ($_.CloseReason -eq [System.Windows.Forms.CloseReason]::UserClosing) {
            $_.Cancel = $true
        }
        try {
            if ($global:wsClient -and $global:wsClient.State -eq [System.Net.WebSockets.WebSocketState]::Open) {
                Log "üîí Cerrando salida WebSocket..."
                $global:wsClient.CloseOutputAsync([System.Net.WebSockets.WebSocketCloseStatus]::NormalClosure, 'Fin de sesi√≥n', [Threading.CancellationToken]::None).GetAwaiter().GetResult()
                Start-Sleep -Milliseconds 300
            }
            Log "‚úÖ Canal de salida cerrado correctamente."
        } catch {
            Log "‚ö†Ô∏è Error al cerrar WebSocket de forma controlada: $($_.Exception.Message)"
        }
    })

    # Controles b√°sicos (logo, etiquetas, timer)
    $logo = New-Object System.Windows.Forms.PictureBox
    $logo.SizeMode = "StretchImage"
    $logo.Size = [System.Drawing.Size]::new(80,80)
    $logo.Location = [System.Drawing.Point]::new(10,10)
    try {
        if (Test-Path $LogoPath) { $logo.Image = [System.Drawing.Image]::FromFile($LogoPath) }
    } catch { Log "‚ö†Ô∏è No se pudo cargar logo: $($_.Exception.Message)" }
    $form.Controls.Add($logo)

    $labelInfo = New-Object System.Windows.Forms.Label
    $labelInfo.Font = New-Object System.Drawing.Font("Segoe UI",12)
    $labelInfo.Location = [System.Drawing.Point]::new(100,10)
    $labelInfo.AutoSize = $true
    $form.Controls.Add($labelInfo)

    $labelTimer = New-Object System.Windows.Forms.Label
    $labelTimer.Font = New-Object System.Drawing.Font("Segoe UI",14,[System.Drawing.FontStyle]::Bold)
    $labelTimer.Location = [System.Drawing.Point]::new(30,100)
    $labelTimer.AutoSize = $true
    $form.Controls.Add($labelTimer)

    # Bot√≥n minimizar/expandir
    $btnReducir = New-Object System.Windows.Forms.Button
    $btnReducir.Text = "Reducir"
    $btnReducir.Size = [System.Drawing.Size]::new(80,28)
    $btnReducir.Location = [System.Drawing.Point]::new($form.Width - 100, $form.Height - 68)
    $btnReducir.Anchor = [System.Windows.Forms.AnchorStyles]::Bottom -bor [System.Windows.Forms.AnchorStyles]::Right
    $btnReducir.Add_Click({
        if ($form.Height -gt 120) {
            $form.Size = [System.Drawing.Size]::new(280,100)
            $btnReducir.Text = "Maximizar"
        } else {
            $form.Size = [System.Drawing.Size]::new(400,200)
            $btnReducir.Text = "Minimizar"
        }
    })
    $form.Controls.Add($btnReducir)

    # ----- Inicio sesi√≥n con API -----
    $response = Call-Api @{ confirmar_inicio = $true }
    if ($response.estado) {
        $form.Show()
        while ($response -and $response.estado -ne "Finalizado" -and $response.estado -ne "Restringido") {
            switch ($response.estado) {
                "Abierto" {
                    Start-Process -FilePath "explorer.exe"
                    $labelInfo.Text = "Usuario: $Username`n MAC: $mac"
                    $labelTimer.ForeColor = [System.Drawing.Color]::DarkGreen
                    $tiempo = if ($response.tiempo_restante) { $response.tiempo_restante } else { 30 }
                    for ($i=$tiempo; $i -ge 0; $i--) {
                        if ($global:TiempoRestante -and $global:TiempoRestante -ne $i) { $i = $global:TiempoRestante }
    $labelTimer.Text = "SESION ACTIVA - Restante: $(Format-Time $i)"
                        $form.Refresh()
                        $waitUntil = (Get-Date).AddSeconds(1)
                        while ((Get-Date) -lt $waitUntil) {
                            [System.Windows.Forms.Application]::DoEvents()
                            Start-Sleep -Milliseconds 50
                        }
                    }
                    $response = Call-Api
                }
                "Suspendido" {
                    # Manejo suspendido (resumido; conservar tu l√≥gica completa)
                    # ... (tu c√≥digo de modal y validaciones permanece aqu√≠)
                    # Para no repetir, llamamos Call-Api en el flujo tal cual
                    # Copia el bloque completo de tu versi√≥n original si lo deseas
                    $response = Call-Api
                }
                "Bloqueado" {
                    $labelTimer.ForeColor = [System.Drawing.Color]::Red
                    $tiempo = if ($response.tiempo_restante) { $response.tiempo_restante } else { 10 }
                    for ($i=$tiempo; $i -ge 0; $i--) {
                        $labelTimer.Text = "üîí BLOQUEADO - Restante: $(Format-Time $i)"
                        $form.Refresh()
                        $waitUntil = (Get-Date).AddSeconds(1)
                        while ((Get-Date) -lt $waitUntil) {
                            [System.Windows.Forms.Application]::DoEvents()
                            Start-Sleep -Milliseconds 50
                        }
                    }
                    $response = Call-Api
                }
                "Error" {
                    [System.Windows.Forms.MessageBox]::Show($response.mensaje, "Error de sesi√≥n", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
                    $form.Close()
                    return
                }
                default {
                    # L√≥gica por defecto / esperar y reconsultar
                    Start-Sleep -Seconds 1
                    $response = Call-Api
                }
            } # switch
        } # while

        if ($response.estado -eq "Finalizado") {
            $labelInfo.ForeColor = [System.Drawing.Color]::Blue
            $labelTimer.Text = "‚úÖ Sesi√≥n finalizada correctamente"
            $form.Refresh()
            Start-Sleep -Seconds 2
            $form.Close()
            Log "‚úÖ Script finalizado completamente."
        }
        if ($response.estado -eq "Restringido") {
            # tu manejo de estado Restringido (puedes reutilizar tu bloque)
            Log "üö´ Usuario restringido (FOLIO)"
        }
    } else {
        Log "‚ùå Error al iniciar sesi√≥n v√≠a API: $($response.mensaje)"
    }
}

# -------------------------
# EJECUCI√ìN: llamar la ventana principal
# -------------------------
Show-VentanaSesion -Titulo "GestiÔøΩn de SesiÔøΩn con API" -ClaveAdmin $DefaultClaveAdmin -LogoPathParam $DefaultLogoPath -ApiUrlParam $DefaultApiUrl

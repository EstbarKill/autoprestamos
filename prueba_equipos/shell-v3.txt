# ============================================================
# üéì SISTEMA DE AUTOPR√âSTAMOS - UNIVERSIDAD SIM√ìN BOL√çVAR
# ============================================================
# Descripci√≥n: Cliente PowerShell para gesti√≥n de sesiones
#              de equipos con integraci√≥n WebSocket + API REST
# Autor: Sistema Autopr√©stamos Unisim√≥n
# Versi√≥n: 2.0 (Refactorizado)
# Fecha: 2025-01-XX
# ============================================================

<#
.SYNOPSIS
    Cliente de autopr√©stamos con control remoto via WebSocket

.DESCRIPTION
    Este script gestiona sesiones de pr√©stamo de equipos integrando:
    - Conexi√≥n WebSocket bidireccional con el servidor
    - Llamadas API REST para validaci√≥n de estados FOLIO
    - Interfaz gr√°fica WinForms para el usuario
    - Control remoto desde dashboard administrativo

.NOTES
    Requiere Windows PowerShell 5.1 o superior
    Dependencias: .NET Framework 4.5+
#>

# ============================================================
# üì¶ SECCI√ìN 1: CARGA DE LIBRER√çAS Y CONFIGURACI√ìN
# ============================================================

# Cargar ensamblados para interfaz gr√°fica
Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing

# Variables globales de configuraci√≥n
$Global:Config = @{
    ServidorWS    = "ws://localhost:8081"
    ApiUrl        = "http://localhost/autoprestamos/prueba_equipos/api.php"
    LogoPath      = "C:\xampp\htdocs\autoprestamos\dashboard-unisimon\assets\img\logo.png"
    IdEquipo      = $env:COMPUTERNAME
    Username      = $env:USERNAME
    ClaveAdmin    = "S1m0n_2025"
    MaxReintentos = 5
    TiempoReintento = 3  # segundos
    TiempoSuspension = 30  # segundos
}

# Variables globales de estado
$Global:wsClient = $null
$Global:SuspendidoProcesado = $false
$Global:MacAddress = $null

# ============================================================
# üìù SECCI√ìN 2: FUNCIONES DE LOGGING Y UTILIDADES
# ============================================================

<#
.SYNOPSIS
    Registra mensajes con timestamp en consola
#>
function Write-Log {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Mensaje,
        
        [ValidateSet('Info', 'Warning', 'Error', 'Success')]
        [string]$Tipo = 'Info'
    )
    
    $timestamp = Get-Date -Format 'HH:mm:ss'
    $prefijo = switch ($Tipo) {
        'Info'    { "‚ÑπÔ∏è" }
        'Warning' { "‚ö†Ô∏è" }
        'Error'   { "‚ùå" }
        'Success' { "‚úÖ" }
    }
    
    $color = switch ($Tipo) {
        'Info'    { 'White' }
        'Warning' { 'Yellow' }
        'Error'   { 'Red' }
        'Success' { 'Green' }
    }
    
    Write-Host "[$timestamp] $prefijo $Mensaje" -ForegroundColor $color
}

<#
.SYNOPSIS
    Formatea segundos en formato HH:MM:SS
#>
function Format-TimeSpan {
    param([int]$Segundos)
    
    $ts = [TimeSpan]::FromSeconds($Segundos)
    return "{0:00}:{1:00}:{2:00}" -f $ts.Hours, $ts.Minutes, $ts.Seconds
}

<#
.SYNOPSIS
    Convierte fecha UTC de FOLIO a hora local de Colombia
#>
function Convert-ToColombiaDate {
    param([string]$UtcString)
    
    try {
        $dtUtc = [System.Xml.XmlConvert]::ToDateTime(
            $UtcString, 
            [System.Xml.XmlDateTimeSerializationMode]::Utc
        )
        $tzCol = [System.TimeZoneInfo]::FindSystemTimeZoneById("SA Pacific Standard Time")
        $dtCol = [System.TimeZoneInfo]::ConvertTimeFromUtc($dtUtc, $tzCol)
        
        return $dtCol.ToString(
            "dddd, dd 'de' MMMM 'de' yyyy",
            [System.Globalization.CultureInfo]::GetCultureInfo("es-CO")
        )
    }
    catch {
        Write-Log "Error al convertir fecha: $_" -Tipo Error
        return $UtcString
    }
}

# ============================================================
# üåê SECCI√ìN 3: DETECCI√ìN DE RED E INTERFAZ
# ============================================================

<#
.SYNOPSIS
    Detecta la interfaz de red activa con salida a Internet
.DESCRIPTION
    Identifica la interfaz con gateway configurado y estado "Up"
    Retorna la direcci√≥n MAC formateada
#>
function Get-ActiveNetworkInterface {
    Write-Log "Detectando interfaz de red activa..." -Tipo Info
    
    $interfazActiva = Get-NetIPConfiguration |
        Where-Object { 
            $_.IPv4DefaultGateway -ne $null -and 
            $_.NetAdapter.Status -eq "Up" 
        } |
        Select-Object -First 1
    
    if ($interfazActiva) {
        $mac = $interfazActiva.NetAdapter.MacAddress.Replace("-", ":")
        $nombre = $interfazActiva.NetAdapter.InterfaceAlias
        $ip = $interfazActiva.IPv4Address.IPAddress
        
        Write-Log "Interfaz detectada: $nombre" -Tipo Success
        Write-Log "MAC: $mac | IP: $ip" -Tipo Info
        
        return @{
            MAC    = $mac
            Nombre = $nombre
            IP     = $ip
        }
    }
    else {
        Write-Log "No se encontr√≥ interfaz con conexi√≥n a Internet" -Tipo Error
        return $null
    }
}

# ============================================================
# üîå SECCI√ìN 4: GESTI√ìN DE WEBSOCKET
# ============================================================

<#
.SYNOPSIS
    Verifica si el servidor WebSocket est√° activo
#>
function Test-ServidorActivo {
    try {
        $resp = Invoke-WebRequest `
            -Uri "http://localhost/autoprestamos/servers/estado_server.php" `
            -UseBasicParsing `
            -TimeoutSec 3
        
        $json = $resp.Content | ConvertFrom-Json
        return ($json.status -eq "corriendo")
    }
    catch {
        Write-Log "No se pudo verificar el servidor: $_" -Tipo Warning
        return $false
    }
}

<#
.SYNOPSIS
    Registra el cliente en el servidor WebSocket
#>
function Register-ClienteWebSocket {
    $payload = @{
        accion = "registro_cliente"
        id     = $Global:Config.IdEquipo
    } | ConvertTo-Json -Compress
    
    try {
        $bytes = [System.Text.Encoding]::UTF8.GetBytes($payload)
        $segment = [System.ArraySegment[byte]]::new($bytes)
        
        $Global:wsClient.SendAsync(
            $segment,
            [System.Net.WebSockets.WebSocketMessageType]::Text,
            $true,
            [Threading.CancellationToken]::None
        ).Wait()
        
        Write-Log "Cliente registrado ‚Üí ID: $($Global:Config.IdEquipo)" -Tipo Success
        return $true
    }
    catch {
        Write-Log "Error al registrar cliente: $_" -Tipo Error
        return $false
    }
}

<#
.SYNOPSIS
    Env√≠a un mensaje JSON al servidor WebSocket
#>
function Send-WebSocketMessage {
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$Payload
    )
    
    if ($Global:wsClient.State -ne [System.Net.WebSockets.WebSocketState]::Open) {
        Write-Log "WebSocket no est√° conectado" -Tipo Warning
        return $false
    }
    
    try {
        $json = $Payload | ConvertTo-Json -Compress
        $bytes = [System.Text.Encoding]::UTF8.GetBytes($json)
        $segment = [System.ArraySegment[byte]]::new($bytes)
        
        $Global:wsClient.SendAsync(
            $segment,
            [System.Net.WebSockets.WebSocketMessageType]::Text,
            $true,
            [Threading.CancellationToken]::None
        ).Wait()
        
        return $true
    }
    catch {
        Write-Log "Error al enviar mensaje WebSocket: $_" -Tipo Error
        return $false
    }
}

<#
.SYNOPSIS
    Procesa acciones de control recibidas desde el dashboard
#>
function Invoke-AccionControl {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Accion,
        [hashtable]$Detalles = @{}
    )
    
    Write-Log "Ejecutando acci√≥n: $Accion" -Tipo Info

    switch ($Accion) {

        # ============================================================
        # üîí BLOQUEAR EQUIPO
        # ============================================================
        "bloquear" {
            Write-Log "üîí Bloqueando equipo..." -Tipo Warning
            rundll32.exe user32.dll,LockWorkStation

            Send-WebSocketMessage -Payload @{
                tipo = "confirmacion"
                id = $Global:Config.IdEquipo
                accion = "bloquear"
                resultado = "ejecutado"
                mensaje = "Equipo bloqueado exitosamente"
            }
        }

        # ============================================================
        # üí§ SUSPENDER EQUIPO
        # ============================================================
        "suspender" {
            Write-Log "üí§ Suspendiendo equipo..." -Tipo Warning

            [System.Windows.Forms.MessageBox]::Show(
                "El equipo se suspender√° en 10 segundos.`n¬øDesea guardar su trabajo?",
                "Suspensi√≥n Programada",
                [System.Windows.Forms.MessageBoxButtons]::OK,
                [System.Windows.Forms.MessageBoxIcon]::Warning
            )

            Start-Sleep -Seconds 10
            rundll32.exe powrprof.dll,SetSuspendState 0,1,0

            Send-WebSocketMessage -Payload @{
                tipo = "confirmacion"
                id = $Global:Config.IdEquipo
                accion = "suspender"
                resultado = "ejecutado"
                mensaje = "Equipo suspendido correctamente"
            }
        }

        # ============================================================
        # ‚õî FINALIZAR SESI√ìN
        # ============================================================
        "finalizar" {
            Write-Log "‚õî Finalizando sesi√≥n..." -Tipo Error

            # Confirmaci√≥n previa al cierre
            Send-WebSocketMessage -Payload @{
                tipo = "confirmacion"
                id = $Global:Config.IdEquipo
                accion = "finalizar"
                resultado = "ejecutado"
                mensaje = "Cerrando sesi√≥n por orden del administrador"
            }

            [System.Windows.Forms.MessageBox]::Show(
                "La sesi√≥n finalizar√° en 15 segundos.`nGuarde su trabajo.",
                "Cierre de Sesi√≥n",
                [System.Windows.Forms.MessageBoxButtons]::OK,
                [System.Windows.Forms.MessageBoxIcon]::Warning
            )

            Start-Sleep -Seconds 15
            shutdown /l /f
        }

        # ============================================================
        # ‚ôªÔ∏è RENOVAR SESI√ìN
        # ============================================================
        "renovar" {
            Write-Log "‚ôªÔ∏è Sesi√≥n renovada por el administrador" -Tipo Success

            [System.Windows.Forms.MessageBox]::Show(
                "‚úÖ Su sesi√≥n ha sido renovada correctamente.",
                "Renovaci√≥n Exitosa",
                [System.Windows.Forms.MessageBoxButtons]::OK,
                [System.Windows.Forms.MessageBoxIcon]::Information
            )

            Send-WebSocketMessage -Payload @{
                tipo = "confirmacion"
                id = $Global:Config.IdEquipo
                accion = "renovar"
                resultado = "ejecutado"
                mensaje = "Sesi√≥n renovada confirmada"
            }
        }

        # ============================================================
        # üí¨ MENSAJE DEL ADMINISTRADOR
        # ============================================================
        "mensaje" {
            $texto = $Detalles.texto -or "Mensaje del administrador"

            [System.Windows.Forms.MessageBox]::Show(
                $texto,
                "Notificaci√≥n del Sistema",
                [System.Windows.Forms.MessageBoxButtons]::OK,
                [System.Windows.Forms.MessageBoxIcon]::Information
            )

            Write-Log "üí¨ Mensaje mostrado al usuario" -Tipo Info

            Send-WebSocketMessage -Payload @{
                tipo = "confirmacion"
                id = $Global:Config.IdEquipo
                accion = "mensaje"
                resultado = "ejecutado"
                mensaje = "Mensaje mostrado al usuario"
            }
        }

        # ============================================================
        # üìä INFORMACI√ìN DEL EQUIPO
        # ============================================================
        "ver_info" {
            Write-Log "üìä Recopilando informaci√≥n del equipo..." -Tipo Info

            $info = @{
                usuario = $env:USERNAME
                equipo  = $env:COMPUTERNAME
                ip      = (Get-NetIPAddress -AddressFamily IPv4 | 
                           Where-Object {$_.InterfaceAlias -notmatch "Loopback"} | 
                           Select-Object -First 1).IPAddress
                mac     = $Global:MacAddress
                so      = (Get-CimInstance Win32_OperatingSystem).Caption
                memoria = [Math]::Round(
                    (Get-CimInstance Win32_ComputerSystem).TotalPhysicalMemory / 1GB, 
                    2
                )
                procesador = (Get-CimInstance Win32_Processor).Name
            }

            Send-WebSocketMessage -Payload @{
                tipo = "info_respuesta"
                id = $Global:Config.IdEquipo
                datos = $info
            }

            Write-Log "Informaci√≥n enviada al servidor" -Tipo Success
        }

        # ============================================================
        # ‚ö†Ô∏è ACCI√ìN DESCONOCIDA
        # ============================================================
        default {
            Write-Log "‚ö†Ô∏è Acci√≥n desconocida: $Accion" -Tipo Warning
            Send-WebSocketMessage -Payload @{
                tipo = "confirmacion"
                id = $Global:Config.IdEquipo
                accion = $Accion
                resultado = "desconocida"
                mensaje = "Acci√≥n no reconocida por el cliente"
            }
        }
    }
}


<#
.SYNOPSIS
    Escucha mensajes del servidor WebSocket en bucle continuo
#>
function Start-WebSocketListener {
    param(
        [Parameter(Mandatory=$true)]
        $WsClient
    )
    
    Write-Log "Iniciando escucha de mensajes WebSocket..." -Tipo Info
    $buffer = New-Object Byte[] 4096
    
    while ($WsClient.State -eq [System.Net.WebSockets.WebSocketState]::Open) {
        try {
            # Recibir mensaje
            $result = $WsClient.ReceiveAsync(
                [ArraySegment[byte]]$buffer,
                [Threading.CancellationToken]::None
            ).Result
            
            if ($result.Count -gt 0) {
                # Decodificar JSON
                $mensaje = [System.Text.Encoding]::UTF8.GetString($buffer, 0, $result.Count)
                
                Write-Log "üì© Mensaje recibido: $mensaje" -Tipo Info
                
                try {
                    $data = $mensaje | ConvertFrom-Json -ErrorAction Stop
                }
                catch {
                    Write-Log "Mensaje JSON inv√°lido: $mensaje" -Tipo Warning
                    continue
                }
                
                # Procesar seg√∫n tipo de mensaje
                switch ($data.tipo) {
                    "control" {
                        Write-Log "üéØ Comando de control recibido: $($data.accion)" -Tipo Info
                        Invoke-AccionControl -Accion $data.accion -Detalles $data
                    }
                    
                    "mensaje" {
                        Write-Log "üí¨ Mensaje del dashboard: $($data.texto)" -Tipo Info
                        [System.Windows.Forms.MessageBox]::Show(
                            $data.texto,
                            "Mensaje del Administrador",
                            [System.Windows.Forms.MessageBoxButtons]::OK,
                            [System.Windows.Forms.MessageBoxIcon]::Information
                        )
                    }
                    
                    "info" {
                        Write-Log "üìä Solicitud de informaci√≥n recibida" -Tipo Info
                        Invoke-AccionControl -Accion "ver_info"
                    }
                    
                    "ping" {
                        # Responder con pong
                        Send-WebSocketMessage -Payload @{
                            tipo = "pong"
                            id = $Global:Config.IdEquipo
                            timestamp = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
                        }
                    }
                    
                    default {
                        Write-Log "Tipo de mensaje no reconocido: $($data.tipo)" -Tipo Warning
                    }
                }
            }
        }
        catch {
            Write-Log "Error en la escucha WebSocket: $_" -Tipo Error
            break
        }
        
        # Peque√±a pausa para no saturar CPU
        Start-Sleep -Milliseconds 200
    }
    
    Write-Log "Conexi√≥n WebSocket cerrada" -Tipo Warning
}

<#
.SYNOPSIS
    Establece conexi√≥n WebSocket con reintentos autom√°ticos
#>
function Connect-WebSocket {
    param([int]$MaxReintentos = 5)
    
    $intentos = 0
    $uri = [System.Uri]$Global:Config.ServidorWS
    
    while ($intentos -le $MaxReintentos) {
        # Verificar que el servidor est√© activo
        if (-not (Test-ServidorActivo)) {
            Write-Log "Servidor WebSocket no disponible" -Tipo Warning
            return $false
        }
        
        try {
            Write-Log "üîå Conectando a $($Global:Config.ServidorWS) (intento $($intentos + 1)/$MaxReintentos)..." -Tipo Info
            
            # Crear nuevo cliente WebSocket
            $Global:wsClient = [System.Net.WebSockets.ClientWebSocket]::new()
            
            # Intentar conexi√≥n
            $Global:wsClient.ConnectAsync($uri, [Threading.CancellationToken]::None).Wait()
            
            # Verificar estado
            if ($Global:wsClient.State -eq [System.Net.WebSockets.WebSocketState]::Open) {
                Write-Log "Conexi√≥n establecida exitosamente" -Tipo Success
                
                # Registrar cliente
                Register-ClienteWebSocket | Out-Null
                
                # Iniciar escucha en segundo plano
# Iniciar escucha de mensajes WebSocket en tiempo real
Start-Job -Name "WebSocketListener" -ScriptBlock {
    param($ws)

    # Cargar funciones necesarias dentro del Job
    Import-Module "$PSScriptRoot\$($MyInvocation.MyCommand.Name)" -Force

    try {
        Start-WebSocketListener -WsClient $ws
    }
    catch {
        Write-Host "[WS JOB] Error en escucha: $_" -ForegroundColor Red
    }
} -ArgumentList $Global:wsClient | Out-Null

                
                return $true
            }
        }
        catch {
            Write-Log "Error de conexi√≥n: $_" -Tipo Error
        }
        
        $intentos++
        if ($intentos -le $MaxReintentos) {
            Write-Log "‚è≥ Reintentando en $($Global:Config.TiempoReintento) segundos..." -Tipo Warning
            Start-Sleep -Seconds $Global:Config.TiempoReintento
        }
    }
    
    Write-Log "L√≠mite de reintentos alcanzado ($MaxReintentos)" -Tipo Error
    return $false
}

# ============================================================
# üåê SECCI√ìN 5: LLAMADAS A API REST
# ============================================================

<#
.SYNOPSIS
    Realiza llamadas HTTP POST a la API de autopr√©stamos
#>
function Invoke-ApiCall {
    param(
        [hashtable]$ExtraBody = @{}
    )
    
    # Construir body base
    $body = @{
        username = $Global:Config.Username
        mac_address = $Global:MacAddress
    } + $ExtraBody
    
    $json = $body | ConvertTo-Json -Compress
    $headers = @{ "Content-Type" = "application/json" }
    
    try {
        Write-Log "üåê Llamando API: $($Global:Config.ApiUrl)" -Tipo Info
        
        $response = Invoke-RestMethod `
            -Uri $Global:Config.ApiUrl `
            -Method Post `
            -Headers $headers `
            -Body $json `
            -TimeoutSec 60
        
        Write-Log "Respuesta API recibida: $($response.estado)" -Tipo Success
        return $response
    }
    catch [System.Net.WebException] {
        $errorMsg = "Error de conexi√≥n con la API: $($_.Exception.Message)"
        Write-Log $errorMsg -Tipo Error
        return @{ estado = "Error"; mensaje = $errorMsg }
    }
    catch {
        $errorMsg = "Error inesperado: $($_.Exception.Message)"
        Write-Log $errorMsg -Tipo Error
        return @{ estado = "Error"; mensaje = $errorMsg }
    }
}

# ============================================================
# üñ•Ô∏è SECCI√ìN 6: INTERFAZ GR√ÅFICA (WINFORMS)
# ============================================================

<#
.SYNOPSIS
    Crea y configura el formulario principal de la sesi√≥n
#>
function New-SessionForm {
    param(
        [string]$Titulo = "Gesti√≥n de Sesi√≥n - Autopr√©stamos"
    )
    
    # Crear formulario
    $form = New-Object System.Windows.Forms.Form
    $form.Text = $Titulo
    $form.Size = [System.Drawing.Size]::new(400, 200)
    $form.StartPosition = "Manual"
    $form.FormBorderStyle = [System.Windows.Forms.FormBorderStyle]::FixedDialog
    $form.ShowInTaskbar = $false
    $form.MinimizeBox = $true
    $form.MaximizeBox = $false
    $form.ControlBox = $true
    
    # Posicionar en esquina inferior derecha
    $form.Location = [System.Drawing.Point]::new(
        [System.Windows.Forms.Screen]::PrimaryScreen.WorkingArea.Width - 400,
        [System.Windows.Forms.Screen]::PrimaryScreen.WorkingArea.Height - 250
    )
    
    # Prevenir cierre por usuario

    
    # ===== LOGO =====
    $logo = New-Object System.Windows.Forms.PictureBox
    $logo.SizeMode = "StretchImage"
    $logo.Size = [System.Drawing.Size]::new(80, 80)
    $logo.Location = [System.Drawing.Point]::new(10, 10)
    
    if (Test-Path $Global:Config.LogoPath) {
        try {
            $logo.Image = [System.Drawing.Image]::FromFile($Global:Config.LogoPath)
        }
        catch {
            Write-Log "Error al cargar logo: $_" -Tipo Warning
        }
    }
    $form.Controls.Add($logo)
    
    # ===== LABEL INFORMACI√ìN =====
    $labelInfo = New-Object System.Windows.Forms.Label
    $labelInfo.Font = New-Object System.Drawing.Font("Segoe UI", 12)
    $labelInfo.Location = [System.Drawing.Point]::new(100, 10)
    $labelInfo.AutoSize = $true
    $labelInfo.Text = "Usuario: $($Global:Config.Username)`nMAC: $Global:MacAddress"
    $form.Controls.Add($labelInfo)
    
    # ===== LABEL TIMER =====
    $labelTimer = New-Object System.Windows.Forms.Label
    $labelTimer.Font = New-Object System.Drawing.Font("Segoe UI", 14, [System.Drawing.FontStyle]::Bold)
    $labelTimer.Location = [System.Drawing.Point]::new(30, 100)
    $labelTimer.AutoSize = $true
    $labelTimer.Text = "Inicializando..."
    $form.Controls.Add($labelTimer)
    
    # ===== BOT√ìN MINIMIZAR =====
    $btnReducir = New-Object System.Windows.Forms.Button
    $btnReducir.Text = "Minimizar"
    $btnReducir.Size = [System.Drawing.Size]::new(80, 28)
    $btnReducir.Location = [System.Drawing.Point]::new($form.Width - 100, $form.Height - 68)
    $btnReducir.Anchor = [System.Windows.Forms.AnchorStyles]::Bottom -bor [System.Windows.Forms.AnchorStyles]::Right
    
    $btnReducir.Add_Click({
        if ($form.Height -gt 120) {
            # Modo compacto
            $form.Size = [System.Drawing.Size]::new(280, 100)
            $logo.Size = [System.Drawing.Size]::new(170, 60)
            $logo.Location = [System.Drawing.Point]::new(0, 0)
            $labelInfo.Location = [System.Drawing.Point]::new(170, 5)
            $labelInfo.Font = New-Object System.Drawing.Font("Segoe UI", 13, [System.Drawing.FontStyle]::Bold)
            $btnReducir.Text = "Maximizar"
        }
        else {
            # Modo normal
            $form.Size = [System.Drawing.Size]::new(400, 200)
            $logo.Size = [System.Drawing.Size]::new(80, 80)
            $logo.Location = [System.Drawing.Point]::new(10, 10)
            $labelInfo.Location = [System.Drawing.Point]::new(100, 10)
            $labelInfo.Font = New-Object System.Drawing.Font("Segoe UI", 12)
            $btnReducir.Text = "Minimizar"
        }
        $form.Refresh()
    })
    
    $form.Controls.Add($btnReducir)
    
    # Retornar formulario y controles
    return @{
        Form = $form
        LabelInfo = $labelInfo
        LabelTimer = $labelTimer
        Logo = $logo
        BtnReducir = $btnReducir
    }
}

<#
.SYNOPSIS
    Crea modal de desbloqueo para sesiones suspendidas
#>
function Show-SuspensionModal {
    param(
        [Parameter(Mandatory=$true)]
        [string]$ClaveCorrecta
    )
    
    Write-Log "Mostrando modal de suspensi√≥n..." -Tipo Warning
    
    # Crear modal
    $modal = New-Object System.Windows.Forms.Form
    $modal.FormBorderStyle = 'None'
    $modal.StartPosition = 'CenterScreen'
    $modal.Size = [System.Drawing.Size]::new(400, 250)
    $modal.BackColor = [System.Drawing.Color]::FromArgb(240, 240, 240)
    $modal.TopMost = $true
    
    # Label t√≠tulo
    $labelModal = New-Object System.Windows.Forms.Label
    $labelModal.Font = New-Object System.Drawing.Font("Segoe UI", 12, [System.Drawing.FontStyle]::Bold)
    $labelModal.Text = "‚è∏ Sesi√≥n suspendida. Ingrese clave:"
    $labelModal.AutoSize = $true
    $labelModal.Location = [System.Drawing.Point]::new(50, 30)
    $modal.Controls.Add($labelModal)
    
    # Barra de progreso
    $progress = New-Object System.Windows.Forms.ProgressBar
    $progress.Location = [System.Drawing.Point]::new(50, 70)
    $progress.Size = [System.Drawing.Size]::new(300, 20)
    $progress.Maximum = $Global:Config.TiempoSuspension
    $modal.Controls.Add($progress)
    
    # TextBox para clave
    $textBox = New-Object System.Windows.Forms.TextBox
    $textBox.UseSystemPasswordChar = $true
    $textBox.Width = 200
    $textBox.Location = [System.Drawing.Point]::new(100, 110)
    $modal.Controls.Add($textBox)
    
    # Bot√≥n Validar
    $btnValidar = New-Object System.Windows.Forms.Button
    $btnValidar.Text = "Validar"
    $btnValidar.Location = [System.Drawing.Point]::new(80, 160)
    $modal.Controls.Add($btnValidar)
    
    # Bot√≥n Cancelar
    $btnCancelar = New-Object System.Windows.Forms.Button
    $btnCancelar.Text = "Cancelar"
    $btnCancelar.Location = [System.Drawing.Point]::new(200, 160)
    $modal.Controls.Add($btnCancelar)
    
    # Variables de estado
    $script:desbloqueado = $false
    $script:cancelado = $false
    $script:intentosFails = $false
    $script:segundos = $Global:Config.TiempoSuspension
    $script:intentos = 0
    
    # Capturar tecla Enter
    $textBox.Add_KeyDown({
        if ($_.KeyCode -eq 'Enter') {
            $btnValidar.PerformClick()
        }
    })
    
    # Evento bot√≥n Validar
    $btnValidar.Add_Click({
        if ($textBox.Text -eq $ClaveCorrecta) {
            $script:desbloqueado = $true
            Write-Log "Clave correcta ingresada" -Tipo Success
            $modal.Close()
        }
        else {
            $script:intentos++
            Write-Log "Clave incorrecta (intento $script:intentos)" -Tipo Warning
            $textBox.Clear()
            $textBox.Focus()
            
            if ($script:intentos -gt 3) {
                Write-Log "Demasiados intentos fallidos" -Tipo Error
                $script:intentosFails = $true
                $modal.Close()
            }
        }
    })
    
    # Evento bot√≥n Cancelar
    $btnCancelar.Add_Click({
        $script:cancelado = $true
        Write-Log "Usuario cancel√≥ la suspensi√≥n" -Tipo Warning
        $modal.Close()
    })
    
    # Timer para countdown
    $timer = New-Object System.Windows.Forms.Timer
    $timer.Interval = 1000
    $timer.Add_Tick({
        if ($script:segundos -ge 0) {
            $progress.Value = $progress.Maximum - $script:segundos
            $script:segundos--
        }
        else {
            $timer.Stop()
            $modal.Close()
        }
    })
    $timer.Start()
    
    # Mostrar modal
    $modal.

ShowDialog() | Out-Null
    
    # Detener timer si sigue activo
    if ($timer.Enabled) {
        $timer.Stop()
    }
    
    # Retornar resultado
    return @{
        Desbloqueado = $script:desbloqueado
        Cancelado = $script:cancelado
        IntentosExcedidos = $script:intentosFails
        TiempoExpirado = ($script:segundos -le 0)
    }
}

# ============================================================
# üéÆ SECCI√ìN 7: L√ìGICA PRINCIPAL DE SESI√ìN
# ============================================================

<#
.SYNOPSIS
    Procesa el estado "Abierto" de la sesi√≥n
#>
function Invoke-EstadoAbierto {
    param(
        [Parameter(Mandatory=$true)]
        $Controles,
        
        [Parameter(Mandatory=$true)]
        $Response
    )
    
    Write-Log "Estado: ABIERTO - Sesi√≥n activa" -Tipo Success
    
    # Abrir explorador de archivos
    Start-Process -FilePath "explorer.exe" -ErrorAction SilentlyContinue
    
    # Actualizar interfaz
    $Controles.LabelInfo.Text = "Usuario: $($Global:Config.Username)`nMAC: $Global:MacAddress"
    $Controles.LabelTimer.ForeColor = [System.Drawing.Color]::DarkGreen
    
    # Obtener tiempo restante
    $tiempo = if ($Response.tiempo_restante) { 
        $Response.tiempo_restante 
    } else { 
        30 
    }
    
    # Countdown
    for ($i = $tiempo; $i -ge 0; $i--) {
        $Controles.LabelTimer.Text = "üü¢ SESI√ìN ACTIVA - Restante: $(Format-TimeSpan $i)"
        $Controles.Form.Refresh()
        
        # Espera no bloqueante
        $waitUntil = (Get-Date).AddSeconds(1)
        while ((Get-Date) -lt $waitUntil) {
            [System.Windows.Forms.Application]::DoEvents()
            Start-Sleep -Milliseconds 50
        }
    }
    
    # Consultar nuevo estado
    return Invoke-ApiCall
}

<#
.SYNOPSIS
    Procesa el estado "Suspendido" de la sesi√≥n
#>
function Invoke-EstadoSuspendido {
    param(
        [Parameter(Mandatory=$true)]
        $Controles,
        
        [Parameter(Mandatory=$true)]
        $Response
    )
    
    if ($Global:SuspendidoProcesado) {
        Write-Log "Estado Suspendido ya procesado, esperando..." -Tipo Warning
        return $Response
    }
    
    $Global:SuspendidoProcesado = $true
    Write-Log "Estado: SUSPENDIDO - Esperando clave administrativa" -Tipo Warning
    
    # Mostrar modal de desbloqueo
    $resultado = Show-SuspensionModal -ClaveCorrecta $Global:Config.ClaveAdmin
    
    # Procesar resultado del modal
    if ($resultado.Desbloqueado) {
        Write-Log "Sesi√≥n desbloqueada con clave correcta" -Tipo Success
        return Invoke-ApiCall -ExtraBody @{ clave_admin = $Global:Config.ClaveAdmin }
    }
    elseif ($resultado.Cancelado) {
        Write-Log "Sesi√≥n cancelada por el usuario ‚Üí Bloqueando" -Tipo Warning
        return Invoke-ApiCall -ExtraBody @{ cancel_suspend = "Cancelar" }
    }
    elseif ($resultado.IntentosExcedidos) {
        Write-Log "Demasiados intentos fallidos ‚Üí Bloqueando" -Tipo Error
        return Invoke-ApiCall -ExtraBody @{ cancel_suspend = "Intentos" }
    }
    elseif ($resultado.TiempoExpirado) {
        Write-Log "Tiempo de suspensi√≥n expirado ‚Üí Bloqueando" -Tipo Error
        return Invoke-ApiCall -ExtraBody @{ cancel_suspend = "Expirado" }
    }
    
    return $Response
}

<#
.SYNOPSIS
    Procesa el estado "Bloqueado" de la sesi√≥n
#>
function Invoke-EstadoBloqueado {
    param(
        [Parameter(Mandatory=$true)]
        $Controles,
        
        [Parameter(Mandatory=$true)]
        $Response
    )
    
    Write-Log "Estado: BLOQUEADO - Penalizaci√≥n activa" -Tipo Error
    
    # Actualizar interfaz
    $Controles.LabelTimer.ForeColor = [System.Drawing.Color]::Red
    
    # Verificar si el check-in fue exitoso
    if ($Response.folioCheckin -and 
        $Response.folioCheckin.raw -and 
        $Response.folioCheckin.raw.loan.status.name -eq "Closed") {
        
        Write-Log "Check-in de FOLIO detectado, consultando nuevo estado..." -Tipo Info
        
        # Consultar estado actualizado
        $newResponse = Invoke-ApiCall
        
        # Espera breve
        $waitUntil = (Get-Date).AddSeconds(1)
        while ((Get-Date) -lt $waitUntil) {
            [System.Windows.Forms.Application]::DoEvents()
            Start-Sleep -Milliseconds 50
        }
        
        return $newResponse
    }
    
    # Obtener tiempo de bloqueo
    $tiempo = if ($Response.tiempo_restante) { 
        $Response.tiempo_restante 
    } else { 
        10 
    }
    
    # Countdown de penalizaci√≥n
    for ($i = $tiempo; $i -ge 0; $i--) {
        $Controles.LabelTimer.Text = "üîí BLOQUEADO - Restante: $(Format-TimeSpan $i)"
        $Controles.Form.Refresh()
        
        # Espera no bloqueante
        $waitUntil = (Get-Date).AddSeconds(1)
        while ((Get-Date) -lt $waitUntil) {
            [System.Windows.Forms.Application]::DoEvents()
            Start-Sleep -Milliseconds 50
        }
    }
    
    # Consultar nuevo estado
    return Invoke-ApiCall
}

<#
.SYNOPSIS
    Procesa el estado "Renovado" de la sesi√≥n
#>
function Invoke-EstadoRenovado {
    param(
        [Parameter(Mandatory=$true)]
        $Controles,
        
        [Parameter(Mandatory=$true)]
        $Response
    )
    
    Write-Log "Estado: RENOVADO - Esperando confirmaci√≥n..." -Tipo Info
    
    # Actualizar interfaz
    $Controles.LabelTimer.ForeColor = [System.Drawing.Color]::Blue
    $Controles.LabelTimer.Text = "‚ôªÔ∏è Renovaci√≥n en curso..."
    $Controles.Form.Refresh()
    
    # Esperar hasta que el estado cambie
    do {
        $newResponse = Invoke-ApiCall
        
        # Espera amigable con UI
        $waitUntil = (Get-Date).AddSeconds(1)
        while ((Get-Date) -lt $waitUntil) {
            [System.Windows.Forms.Application]::DoEvents()
            Start-Sleep -Milliseconds 50
        }
        
    } while ($newResponse.estado -eq "Renovado" -or $newResponse.estado -eq "Renovando")
    
    return $newResponse
}

<#
.SYNOPSIS
    Procesa el estado "Error" de la sesi√≥n
#>
function Invoke-EstadoError {
    param(
        [Parameter(Mandatory=$true)]
        $Controles,
        
        [Parameter(Mandatory=$true)]
        $Response
    )
    
    Write-Log "Estado: ERROR - $($Response.mensaje)" -Tipo Error
    
    # Mostrar mensaje de error
    [System.Windows.Forms.MessageBox]::Show(
        $Response.mensaje,
        "‚ùå Error de Sesi√≥n",
        [System.Windows.Forms.MessageBoxButtons]::OK,
        [System.Windows.Forms.MessageBoxIcon]::Error
    )
    
    # Cerrar formulario
    $Controles.Form.Close()
}

<#
.SYNOPSIS
    Procesa el estado "Restringido" (bloqueos FOLIO)
#>
function Invoke-EstadoRestringido {
    param(
        [Parameter(Mandatory=$true)]
        $Controles,
        
        [Parameter(Mandatory=$true)]
        $Response
    )
    
    Write-Log "Estado: RESTRINGIDO - Usuario con bloqueos en FOLIO" -Tipo Error
    
    # Redimensionar ventana
    $Controles.Form.Location = [System.Drawing.Point]::new(
        [System.Windows.Forms.Screen]::PrimaryScreen.WorkingArea.Width - 1400,
        [System.Windows.Forms.Screen]::PrimaryScreen.WorkingArea.Height - 800
    )
    $Controles.Form.Size = [System.Drawing.Size]::new(900, 500)
    
    # Actualizar t√≠tulo
    $Controles.LabelInfo.ForeColor = [System.Drawing.Color]::Red
    $Controles.LabelInfo.Font = New-Object System.Drawing.Font("Segoe UI", 16, [System.Drawing.FontStyle]::Bold)
    $Controles.LabelInfo.Text = "üö´ ACCESO RESTRINGIDO: Usuario bloqueado en FOLIO"
    $Controles.LabelInfo.Location = [System.Drawing.Point]::new(50, 20)
    
    # Crear cuadro de texto para mostrar bloqueos
    $txtBloqueos = New-Object System.Windows.Forms.TextBox
    $txtBloqueos.Multiline = $true
    $txtBloqueos.ScrollBars = "Vertical"
    $txtBloqueos.Font = New-Object System.Drawing.Font("Consolas", 12)
    $txtBloqueos.ReadOnly = $true
    $txtBloqueos.BackColor = [System.Drawing.Color]::White
    $txtBloqueos.Size = [System.Drawing.Size]::new(850, 350)
    $txtBloqueos.Location = [System.Drawing.Point]::new(20, 100)
    $Controles.Form.Controls.Add($txtBloqueos)
    
    # Formatear bloqueos manuales
    if ($Response.bloqueos.manuales) {
        $detalles = foreach ($m in $Response.bloqueos.manuales) {
            "üìå BLOQUEO MANUAL`r`n" +
            "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`r`n" +
            "Tipo: $($m.type)`r`n" +
            "Descripci√≥n: $($m.desc)`r`n" +
            "Mensaje al usuario: $($m.patronMessage)`r`n" +
            "Fecha de expiraci√≥n: $(Convert-ToColombiaDate $m.expirationDate)`r`n" +
            "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`r`n`r`n"
        }
        $txtBloqueos.Text = ($detalles -join "`r`n")
    }
    # Formatear bloqueos autom√°ticos
    elseif ($Response.bloqueos.automaticos) {
        $detalles = foreach ($a in $Response.bloqueos.automaticos) {
            "‚ö° BLOQUEO AUTOM√ÅTICO`r`n" +
            "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`r`n" +
            "Raz√≥n: $($a.message)`r`n" +
            "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`r`n`r`n"
        }
        $txtBloqueos.Text = ($detalles -join "`r`n")
    }
    
    # Actualizar bot√≥n cerrar con countdown
    $Controles.BtnReducir.Size = [System.Drawing.Size]::new(120, 40)
    $Controles.BtnReducir.Location = [System.Drawing.Point]::new(760, 420)
    $Controles.BtnReducir.Font = New-Object System.Drawing.Font("Segoe UI", 10, [System.Drawing.FontStyle]::Bold)
    
    # Timer de autocierre (6 segundos)
    $segundos = 6
    for ($i = $segundos; $i -ge 1; $i--) {
        $Controles.BtnReducir.Text = "Cerrar ($i)"
        $Controles.Form.Refresh()
        
        $waitUntil = (Get-Date).AddSeconds(1)
        while ((Get-Date) -lt $waitUntil) {
            [System.Windows.Forms.Application]::DoEvents()
            Start-Sleep -Milliseconds 50
        }
    }
    
    # Cerrar formulario
    $Controles.Form.Close()
}

<#
.SYNOPSIS
    Procesa el estado "Finalizado" de la sesi√≥n
#>
function Invoke-EstadoFinalizado {
    param(
        [Parameter(Mandatory=$true)]
        $Controles,
        
        [Parameter(Mandatory=$true)]
        $Response
    )
    
    Write-Log "Estado: FINALIZADO - Sesi√≥n completada" -Tipo Success
    
    # Actualizar interfaz
    $Controles.LabelInfo.ForeColor = [System.Drawing.Color]::Blue
    $Controles.LabelTimer.Text = "‚úÖ Sesi√≥n finalizada correctamente"
    $Controles.LabelTimer.ForeColor = [System.Drawing.Color]::Green
    $Controles.Form.Refresh()
    
    # Esperar 2 segundos antes de cerrar
    Start-Sleep -Seconds 2
    
    # Cerrar formulario
    $Controles.Form.Close()
}

<#
.SYNOPSIS
    Bucle principal de la sesi√≥n con m√°quina de estados
#>
function Start-SessionLoop {
    Write-Log "Iniciando bucle principal de sesi√≥n..." -Tipo Info
    
    # Crear formulario
    $controles = New-SessionForm
    
    # Consultar estado inicial
    $response = Invoke-ApiCall -ExtraBody @{ confirmar_inicio = "true" }
    
    if (-not $response.estado) {
        Write-Log "No se pudo obtener estado inicial de la API" -Tipo Error
        return
    }
    
    # Mostrar formulario
    $controles.Form.Show()
    
    # Bucle de estados
    while ($response -and 
           $response.estado -ne "Finalizado" -and 
           $response.estado -ne "Restringido") {
        
        Write-Log "Estado actual: $($response.estado)" -Tipo Info
        
        # Reset flag de suspensi√≥n si el estado cambi√≥
        if ($response.estado -ne "Suspendido") {
            $Global:SuspendidoProcesado = $false
        }
        
        # M√°quina de estados
        switch ($response.estado) {
            "Abierto" {
                $response = Invoke-EstadoAbierto -Controles $controles -Response $response
            }
            
            "Suspendido" {
                $response = Invoke-EstadoSuspendido -Controles $controles -Response $response
            }
            
            "Bloqueado" {
                $response = Invoke-EstadoBloqueado -Controles $controles -Response $response
            }
            
            "Renovado" {
                $response = Invoke-EstadoRenovado -Controles $controles -Response $response
            }
            
            "Error" {
                Invoke-EstadoError -Controles $controles -Response $response
                return
            }
            
            default {
                # Verificar si FOLIO cerr√≥ el pr√©stamo
                if ($response.folioResp -and 
                    $response.folioResp.raw.loan.status.name -eq "Closed") {
                    Write-Log "Pr√©stamo cerrado en FOLIO" -Tipo Info
                    $controles.Form.Close()
                    return
                }
                
                Write-Log "Estado desconocido: $($response.estado)" -Tipo Warning
                Start-Sleep -Seconds 2
                $response = Invoke-ApiCall
            }
        }
        
        # Peque√±a pausa para evitar saturaci√≥n
        Start-Sleep -Milliseconds 100
    }
    
    # Procesar estados finales
    if ($response.estado -eq "Finalizado") {
        Invoke-EstadoFinalizado -Controles $controles -Response $response
    }
    elseif ($response.estado -eq "Restringido") {
        Invoke-EstadoRestringido -Controles $controles -Response $response
    }
    
    Write-Log "Bucle de sesi√≥n finalizado" -Tipo Success
}

# ============================================================
# üöÄ SECCI√ìN 8: INICIALIZACI√ìN Y EJECUCI√ìN PRINCIPAL
# ============================================================

<#
.SYNOPSIS
    Inicializa el sistema y verifica dependencias
#>
function Initialize-System {
    Write-Log "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" -Tipo Info
    Write-Log "SISTEMA DE AUTOPR√âSTAMOS - UNIVERSIDAD SIM√ìN BOL√çVAR" -Tipo Info
    Write-Log "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" -Tipo Info
    
    # Detectar interfaz de red
    Write-Log "Detectando configuraci√≥n de red..." -Tipo Info
    $networkInfo = Get-ActiveNetworkInterface
    
    if (-not $networkInfo) {
        Write-Log "No se pudo detectar la red. Abortando..." -Tipo Error
        return $false
    }
    
    $Global:MacAddress = $networkInfo.MAC
    
    # Verificar logo
    if (-not (Test-Path $Global:Config.LogoPath)) {
        Write-Log "Logo no encontrado: $($Global:Config.LogoPath)" -Tipo Warning
    }
    
    # Conectar WebSocket
    Write-Log "Estableciendo conexi√≥n WebSocket..." -Tipo Info
    $wsConnected = Connect-WebSocket -MaxReintentos $Global:Config.MaxReintentos
    
    if (-not $wsConnected) {
        Write-Log "No se pudo conectar al WebSocket" -Tipo Warning
        Write-Log "El sistema funcionar√° sin comunicaci√≥n en tiempo real" -Tipo Warning
    }
    
    Write-Log "Inicializaci√≥n completada" -Tipo Success
    return $true
}

<#
.SYNOPSIS
    Limpia recursos antes de salir
#>
function Clear-Resources {
    Write-Log "Limpiando recursos..." -Tipo Info
    
    # Cerrar WebSocket si est√° abierto
    if ($Global:wsClient -and 
        $Global:wsClient.State -eq [System.Net.WebSockets.WebSocketState]::Open) {
        
        try {
            Write-Log "Cerrando conexi√≥n WebSocket..." -Tipo Info
            
            $Global:wsClient.CloseOutputAsync(
                'NormalClosure',
                'Fin de sesi√≥n',
                [Threading.CancellationToken]::None
            ).GetAwaiter().GetResult()
            
            Start-Sleep -Milliseconds 300
            Write-Log "WebSocket cerrado correctamente" -Tipo Success
        }
        catch {
            Write-Log "Error al cerrar WebSocket: $_" -Tipo Warning
        }
    }
    
    # Detener jobs en segundo plano
    $jobs = Get-Job -Name "WebSocketListener", "PingServidor" -ErrorAction SilentlyContinue
    if ($jobs) {
        Write-Log "Deteniendo jobs en segundo plano..." -Tipo Info
        $jobs | Stop-Job
        $jobs | Remove-Job -Force
    }
    
    Write-Log "Recursos liberados" -Tipo Success
}

# ============================================================
# üé¨ PUNTO DE ENTRADA PRINCIPAL
# ============================================================

try {
    # Banner de inicio
    Clear-Host
    Write-Host ""
    Write-Host "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Cyan
    Write-Host "‚ïë                                                            ‚ïë" -ForegroundColor Cyan
    Write-Host "‚ïë        SISTEMA DE AUTOPR√âSTAMOS - UNISIM√ìN                ‚ïë" -ForegroundColor Cyan
    Write-Host "‚ïë        Cliente PowerShell v2.0                            ‚ïë" -ForegroundColor Cyan
    Write-Host "‚ïë                                                            ‚ïë" -ForegroundColor Cyan
    Write-Host "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Cyan
    Write-Host ""
    
    # Inicializar sistema
    $initialized = Initialize-System
    
    if (-not $initialized) {
        Write-Log "Fallo en la inicializaci√≥n. Abortando..." -Tipo Error
        exit 1
    }
    
    # Iniciar job de monitoreo (ping peri√≥dico)
    Start-Job -Name "PingServidor" -ScriptBlock {
        param($Config)
        
        while ($true) {
            try {
                $ping = Test-Connection -ComputerName "localhost" -Count 1 -Quiet -ErrorAction SilentlyContinue
                
                if (-not $ping) {
                    Write-Host "[PING] ‚ö†Ô∏è Sin respuesta del servidor" -ForegroundColor Yellow
                }
            }
            catch {
                # Silenciar errores de ping
            }
            
            Start-Sleep -Seconds 30
        }
    } -ArgumentList $Global:Config | Out-Null
    
    # Ejecutar bucle principal de sesi√≥n
    Start-SessionLoop
    
    Write-Log "Ejecuci√≥n completada exitosamente" -Tipo Success
}
catch {
    Write-Log "Error cr√≠tico: $($_.Exception.Message)" -Tipo Error
    Write-Log "Stack Trace: $($_.ScriptStackTrace)" -Tipo Error
}
# ============================================================
# FIN DEL SCRIPT
# ============================================================
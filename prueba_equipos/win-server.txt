# ============================================================
# üéì SISTEMA DE AUTOPR√âSTAMOS - ARQUITECTURA DUAL PROCESS
# ============================================================
# Versi√≥n: 2.2 (Depuraci√≥n Completa - Error .Text Resuelto)
# ============================================================

Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing

# ============================================================
# üì¶ CONFIGURACI√ìN GLOBAL
# ============================================================

$Global:Config = @{
    ServidorWS    = "ws://localhost:8081"
    ApiUrl        = "http://localhost/autoprestamos/prueba_equipos/api.php"
    LogoPath      = "C:\xampp\htdocs\autoprestamos\dashboard-unisimon\assets\img\logo.png"
    IdEquipo      = $env:COMPUTERNAME
    Username      = $env:USERNAME
    ClaveAdmin    = "S1m0n_2025"
    MaxReintentos = 5
    TiempoReintento = 3
    TiempoSuspension = 30
}

# Variables de sincronizaci√≥n entre procesos
$Global:SharedState = [hashtable]::Synchronized(@{
    WebSocketConnected = $false
    LastMessage = $null
    CommandQueue = [System.Collections.Queue]::Synchronized((New-Object System.Collections.Queue))
    MacAddress = $null
    SessionActive = $true
    WSClientReference = $null  # Referencia thread-safe al cliente WS
})

# ============================================================
# üîç FUNCIONES DE UTILIDAD
# ============================================================

function Write-Log {
    param(
        [string]$Mensaje,
        [ValidateSet('Info', 'Warning', 'Error', 'Success')]
        [string]$Tipo = 'Info'
    )
    
    $timestamp = Get-Date -Format 'HH:mm:ss'
    $prefijo = switch ($Tipo) {
        'Info'    { "‚ÑπÔ∏è" }
        'Warning' { "‚ö†Ô∏è" }
        'Error'   { "‚ùå" }
        'Success' { "‚úÖ" }
    }
    
    $color = switch ($Tipo) {
        'Info'    { 'White' }
        'Warning' { 'Yellow' }
        'Error'   { 'Red' }
        'Success' { 'Green' }
    }
    
    try {
        Write-Host "[$timestamp] $prefijo [$Tipo] $Mensaje" -ForegroundColor $color
    }
    catch {
        # Silenciar errores de logging para no romper el script
    }
}

function Format-TimeSpan {
    param([int]$Segundos)
    $ts = [TimeSpan]::FromSeconds($Segundos)
    return "{0:00}:{1:00}:{2:00}" -f $ts.Hours, $ts.Minutes, $ts.Seconds
}

function Convert-ToColombiaDate {
    param([string]$UtcString)
    try {
        $dtUtc = [System.Xml.XmlConvert]::ToDateTime($UtcString, [System.Xml.XmlDateTimeSerializationMode]::Utc)
        $tzCol = [System.TimeZoneInfo]::FindSystemTimeZoneById("SA Pacific Standard Time")
        $dtCol = [System.TimeZoneInfo]::ConvertTimeFromUtc($dtUtc, $tzCol)
        return $dtCol.ToString("dddd, dd 'de' MMMM 'de' yyyy", [System.Globalization.CultureInfo]::GetCultureInfo("es-CO"))
    }
    catch {
        return $UtcString
    }
}

function Get-ActiveNetworkInterface {
    Write-Log "Detectando interfaz de red activa..." -Tipo Info
    
    $interfazActiva = Get-NetIPConfiguration |
        Where-Object { $_.IPv4DefaultGateway -ne $null -and $_.NetAdapter.Status -eq "Up" } |
        Select-Object -First 1
    
    if ($interfazActiva) {
        $mac = $interfazActiva.NetAdapter.MacAddress
        $nombre = $interfazActiva.NetAdapter.InterfaceAlias
        $ip = $interfazActiva.IPv4Address.IPAddress
        
        Write-Log "Interfaz detectada: $nombre (MAC: $mac)" -Tipo Success
        return @{ MAC = $mac; Nombre = $nombre; IP = $ip }
    }
    
    Write-Log "No se encontr√≥ interfaz con conexi√≥n a Internet" -Tipo Error
    return $null
}

# ============================================================
# üîå PROCESO WEBSOCKET INDEPENDIENTE (RUNSPACE)
# ============================================================

$Global:WebSocketRunspace = $null
$Global:WebSocketPowerShell = $null

function Start-WebSocketProcess {
    Write-Log "üîÑ Iniciando proceso WebSocket independiente..." -Tipo Info
    
    # Crear Runspace independiente
    $Global:WebSocketRunspace = [runspacefactory]::CreateRunspace()
    $Global:WebSocketRunspace.Open()
    
    # Compartir variables globales con el runspace
    $Global:WebSocketRunspace.SessionStateProxy.SetVariable("Config", $Global:Config)
    $Global:WebSocketRunspace.SessionStateProxy.SetVariable("SharedState", $Global:SharedState)
    
    # Crear PowerShell instance
    $Global:WebSocketPowerShell = [powershell]::Create()
    $Global:WebSocketPowerShell.Runspace = $Global:WebSocketRunspace
    
    # Script del proceso WebSocket
    $wsScript = {
        function Write-WSLog {
            param([string]$Mensaje, [string]$Tipo = 'Info')
            $timestamp = Get-Date -Format 'HH:mm:ss'
            $prefijo = switch ($Tipo) {
                'Info' { "üåê" }; 'Warning' { "‚ö†Ô∏è" }; 'Error' { "‚ùå" }; 'Success' { "‚úÖ" }
            }
            try {
                Write-Host "[$timestamp] $prefijo [WS-PROCESS] $Mensaje"
            }
            catch { }
        }
        
        function Send-WSMessage {
            param($WsClient, [hashtable]$Payload)
            
            if (-not $WsClient -or $WsClient.State -ne [System.Net.WebSockets.WebSocketState]::Open) {
                return $false
            }
            
            try {
                $json = $Payload | ConvertTo-Json -Compress
                $bytes = [System.Text.Encoding]::UTF8.GetBytes($json)
                $segment = [System.ArraySegment[byte]]::new($bytes)
                $WsClient.SendAsync($segment, [System.Net.WebSockets.WebSocketMessageType]::Text, $true, [Threading.CancellationToken]::None).Wait(3000)
                return $true
            }
            catch {
                Write-WSLog "Error al enviar mensaje: $_" -Tipo Error
                return $false
            }
        }
        
        function Connect-WSClient {
            param([int]$MaxReintentos = 5)
            
            $intentos = 0
            $uri = [System.Uri]$Config.ServidorWS
            
            while ($intentos -lt $MaxReintentos -and $SharedState.SessionActive) {
                try {
                    Write-WSLog "Conectando a $($Config.ServidorWS) (intento $($intentos + 1)/$MaxReintentos)..." -Tipo Info
                    
                    $ws = [System.Net.WebSockets.ClientWebSocket]::new()
                    $ws.ConnectAsync($uri, [Threading.CancellationToken]::None).Wait()
                    
                    if ($ws.State -eq [System.Net.WebSockets.WebSocketState]::Open) {
                        Write-WSLog "‚úÖ Conectado exitosamente" -Tipo Success
                        
                        # Registrar cliente
                        $registrado = Send-WSMessage -WsClient $ws -Payload @{
                            tipo = "registro"
                            accion = "getRegistro"
                            origen = "equipo"
                            nombre_equipo = $Config.IdEquipo
                        }
                        
                        if ($registrado) {
                            Write-WSLog "üìù Cliente registrado: $($Config.IdEquipo)" -Tipo Success
                            $SharedState.WebSocketConnected = $true
                            $SharedState.WSClientReference = $ws
                            return $ws
                        }
                    }
                }
                catch {
                    Write-WSLog "Error de conexi√≥n: $_" -Tipo Error
                }
                
                $intentos++
                Start-Sleep -Seconds $Config.TiempoReintento
            }
            
            Write-WSLog "‚ùå No se pudo conectar despu√©s de $MaxReintentos intentos" -Tipo Error
            $SharedState.WebSocketConnected = $false
            return $null
        }
        
        function Start-WSListener {
            param($WsClient)
            
            Write-WSLog "üëÇ Iniciando escucha continua de mensajes..." -Tipo Success
            $buffer = New-Object Byte[] 8192
            
            while ($WsClient.State -eq [System.Net.WebSockets.WebSocketState]::Open -and $SharedState.SessionActive) {
                try {
                    $result = $WsClient.ReceiveAsync([ArraySegment[byte]]$buffer, [Threading.CancellationToken]::None).Result
                    
                    if ($result.Count -gt 0) {
                        $mensaje = [System.Text.Encoding]::UTF8.GetString($buffer, 0, $result.Count)
                        Write-WSLog "üì© Recibido: $mensaje" -Tipo Info
                        
                        try {
                            $data = $mensaje | ConvertFrom-Json
                            
                            # Validar origen
                            if ($data.origen -ne "server") {
                                Write-WSLog "‚õî Origen no autorizado: $($data.origen)" -Tipo Warning
                                continue
                            }
                            
                            # Responder a pings inmediatamente (DENTRO DEL RUNSPACE)
                            if ($data.tipo -eq "ping") {
                                Send-WSMessage -WsClient $WsClient -Payload @{
                                    tipo = "pong"
                                    id = $Config.IdEquipo
                                    timestamp = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
                                } | Out-Null
                                Write-WSLog "üèì Pong enviado" -Tipo Info
                                continue
                            }
                            
                            # Encolar comando para procesamiento
                            $SharedState.CommandQueue.Enqueue($data)
                            $SharedState.LastMessage = $mensaje
                            
                            Write-WSLog "‚úÖ Encolado: $($data.tipo) - $($data.accion)" -Tipo Success
                        }
                        catch {
                            Write-WSLog "‚ö†Ô∏è Error JSON: $_" -Tipo Warning
                        }
                    }
                }
                catch {
                    Write-WSLog "‚ùå Error escucha: $_" -Tipo Error
                    break
                }
                
                Start-Sleep -Milliseconds 100
            }
            
            Write-WSLog "‚ö†Ô∏è Listener finalizado. Estado: $($WsClient.State)" -Tipo Warning
        }
        
        # ===== BUCLE PRINCIPAL DEL PROCESO WEBSOCKET =====
        Write-WSLog "üöÄ Proceso WebSocket iniciado" -Tipo Success
        
        while ($SharedState.SessionActive) {
            $ws = Connect-WSClient -MaxReintentos 5
            
            if ($ws) {
                Start-WSListener -WsClient $ws
                
                # Cerrar limpiamente
                try {
                    if ($ws.State -eq [System.Net.WebSockets.WebSocketState]::Open) {
                        $ws.CloseAsync('NormalClosure', 'Reconexi√≥n', [Threading.CancellationToken]::None).Wait(2000)
                    }
                    $ws.Dispose()
                }
                catch {
                    Write-WSLog "‚ö†Ô∏è Error al cerrar: $_" -Tipo Warning
                }
                
                $SharedState.WebSocketConnected = $false
                $SharedState.WSClientReference = $null
            }
            
            if ($SharedState.SessionActive) {
                Write-WSLog "üîÑ Reintentando en 5 segundos..." -Tipo Warning
                Start-Sleep -Seconds 5
            }
        }
        
        Write-WSLog "üõë Proceso WebSocket finalizado" -Tipo Info
    }
    
    # Ejecutar de forma as√≠ncrona
    $Global:WebSocketPowerShell.AddScript($wsScript) | Out-Null
    $Global:WebSocketPowerShell.BeginInvoke() | Out-Null
    
    Write-Log "‚úÖ Proceso WebSocket iniciado en runspace independiente" -Tipo Success
}

function Stop-WebSocketProcess {
    Write-Log "üõë Deteniendo proceso WebSocket..." -Tipo Warning
    
    $Global:SharedState.SessionActive = $false
    Start-Sleep -Seconds 2
    
    if ($Global:WebSocketPowerShell) {
        try {
            $Global:WebSocketPowerShell.Stop()
            $Global:WebSocketPowerShell.Dispose()
        }
        catch { }
    }
    
    if ($Global:WebSocketRunspace) {
        try {
            $Global:WebSocketRunspace.Close()
            $Global:WebSocketRunspace.Dispose()
        }
        catch { }
    }
    
    Write-Log "‚úÖ Proceso WebSocket detenido" -Tipo Success
}

# ============================================================
# üéÆ PROCESADOR DE COMANDOS WEBSOCKET
# ============================================================

function Invoke-AccionControl {
    param(
        [string]$Accion,
        [hashtable]$Detalles = @{}
    )
    
    Write-Log "üéØ Ejecutando acci√≥n: $Accion" -Tipo Info
    
    # Funci√≥n para enviar confirmaci√≥n
    function Send-Confirmacion {
        param([string]$Resultado, [string]$Mensaje)
        
        $payload = @{
            tipo = "confirmacion"
            origen = "equipo"
            nombre_eq = $Global:Config.IdEquipo
            accion = $Accion
            resultado = $Resultado
            mensaje = $Mensaje
            timestamp = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
        }
        
        if ($Detalles.corr) {
            $payload.corr = $Detalles.corr
        }
        
        # Intentar enviar por WebSocket si est√° disponible
        try {
            $wsClient = $Global:SharedState.WSClientReference
            
            if ($wsClient -and $wsClient.State -eq [System.Net.WebSockets.WebSocketState]::Open) {
                $json = $payload | ConvertTo-Json -Compress
                $bytes = [System.Text.Encoding]::UTF8.GetBytes($json)
                $segment = [System.ArraySegment[byte]]::new($bytes)
                $wsClient.SendAsync($segment, [System.Net.WebSockets.WebSocketMessageType]::Text, $true, [Threading.CancellationToken]::None).Wait(3000)
                Write-Log "‚úÖ Confirmaci√≥n enviada" -Tipo Success
            }
            else {
                Write-Log "‚ö†Ô∏è WebSocket no disponible para enviar confirmaci√≥n" -Tipo Warning
            }
        }
        catch {
            Write-Log "‚ö†Ô∏è Error al enviar confirmaci√≥n: $_" -Tipo Warning
        }
    }
    
    switch ($Accion) {
        "bloquear" {
            Write-Log "üîí Bloqueando sesion..." -Tipo Warning
            Send-Confirmacion -Resultado "ejecutando" -Mensaje "Bloqueando equipo..."
            Start-Sleep -Milliseconds 500
            
            try {
                Write-Log "üîí" -Tipo Warning
                #shutdown /l /f
                Send-Confirmacion -Resultado "ejecutado" -Mensaje "Equipo bloqueado exitosamente"
            }
            catch {
                Send-Confirmacion -Resultado "error" -Mensaje "Error al bloquear: $_"
            }
        }
        
        "suspender" {
            Write-Log "üí§ Suspendiendo equipo..." -Tipo Warning
            Send-Confirmacion -Resultado "ejecutando" -Mensaje "Preparando suspensi√≥n..."
            
            try {
                [System.Windows.Forms.MessageBox]::Show(
                    "El equipo se suspender√° en 10 segundos.`n¬øDesea guardar su trabajo?",
                    "Suspensi√≥n Programada",
                    [System.Windows.Forms.MessageBoxButtons]::OK,
                    [System.Windows.Forms.MessageBoxIcon]::Warning
                ) | Out-Null
                
                Start-Sleep -Seconds 10
                Send-Confirmacion -Resultado "ejecutado" -Mensaje "Suspendiendo..."
            }
            catch {
                Send-Confirmacion -Resultado "error" -Mensaje "Error al suspender: $_"
            }
        }
        
        "finalizar" {
            Write-Log "‚õî Finalizando sesi√≥n..." -Tipo Error
            Send-Confirmacion -Resultado "ejecutando" -Mensaje "Cerrando sesi√≥n..."
            try {
                [System.Windows.Forms.MessageBox]::Show(
                    "La sesi√≥n finalizar√° en 5 segundos.`nGuarde su trabajo.",
                    "Cierre de Sesi√≥n"
                ) | Out-Null
                Invoke-EstadoFinalizado -Controles $controles -Response $response = "finalizado"
                Start-Sleep -Seconds 5
                Send-Confirmacion -Resultado "ejecutado" -Mensaje "Cerrando sesi√≥n..."
                return Invoke-ApiCall
                exit
                #shutdown /l /f
            }
            catch {
                Send-Confirmacion -Resultado "error" -Mensaje "Error al cerrar: $_"
            }
        }
        
        "renovar" {
            Write-Log "‚ôªÔ∏è Sesi√≥n renovada" -Tipo Success
            Send-Confirmacion -Resultado "ejecutado" -Mensaje "Renovaci√≥n confirmada"
            
            try {
                [System.Windows.Forms.MessageBox]::Show(
                    "‚úÖ Su sesi√≥n ha sido renovada correctamente.",
                    "Renovaci√≥n Exitosa"
                ) | Out-Null
            }
            catch { }
        }
        
        "mensaje" {
            $texto = if ($Detalles.texto) { $Detalles.texto } else { "Mensaje del administrador" }
            Write-Log "üí¨ Mostrando mensaje" -Tipo Info
            
            try {
                [System.Windows.Forms.MessageBox]::Show(
                    $texto,
                    "Notificaci√≥n del Sistema",
                    [System.Windows.Forms.MessageBoxButtons]::OK,
                    [System.Windows.Forms.MessageBoxIcon]::Information
                ) | Out-Null
                
                Send-Confirmacion -Resultado "ejecutado" -Mensaje "Mensaje mostrado"
            }
            catch {
                Send-Confirmacion -Resultado "error" -Mensaje "Error al mostrar mensaje"
            }
        }
        
        "ver_info" {
            Write-Log "üìä Recopilando informaci√≥n..." -Tipo Info
            
            try {
                $info = @{
                    usuario = $env:USERNAME
                    equipo = $env:COMPUTERNAME
                    ip = (Get-NetIPAddress -AddressFamily IPv4 | 
                          Where-Object {$_.InterfaceAlias -notmatch "Loopback"} | 
                          Select-Object -First 1).IPAddress
                    mac = $Global:SharedState.MacAddress
                    so = (Get-CimInstance Win32_OperatingSystem).Caption
                    memoria = [Math]::Round((Get-CimInstance Win32_ComputerSystem).TotalPhysicalMemory / 1GB, 2)
                    procesador = (Get-CimInstance Win32_Processor).Name
                }
                
                $wsClient = $Global:SharedState.WSClientReference
                if ($wsClient -and $wsClient.State -eq [System.Net.WebSockets.WebSocketState]::Open) {
                    $payload = @{
                        tipo = "info_respuesta"
                        id = $Global:Config.IdEquipo
                        datos = $info
                    } | ConvertTo-Json -Compress
                    
                    $bytes = [System.Text.Encoding]::UTF8.GetBytes($payload)
                    $segment = [System.ArraySegment[byte]]::new($bytes)
                    $wsClient.SendAsync($segment, [System.Net.WebSockets.WebSocketMessageType]::Text, $true, [Threading.CancellationToken]::None).Wait(3000)
                    
                    Write-Log "‚úÖ Informaci√≥n enviada" -Tipo Success
                }
            }
            catch {
                Write-Log "‚ùå Error al recopilar info: $_" -Tipo Error
                Send-Confirmacion -Resultado "error" -Mensaje "Error al obtener informaci√≥n"
            }
        }
        
        default {
            Write-Log "‚ö†Ô∏è Acci√≥n desconocida: $Accion" -Tipo Warning
            Send-Confirmacion -Resultado "desconocida" -Mensaje "Acci√≥n no reconocida"
        }
    }
}

# Funci√≥n auxiliar para convertir PSCustomObject a Hashtable
function ConvertTo-Hashtable {
    param([Parameter(ValueFromPipeline)]$InputObject)
    
    process {
        if ($null -eq $InputObject) { return $null }
        
        if ($InputObject -is [System.Collections.IDictionary]) {
            return $InputObject
        }
        
        if ($InputObject -is [PSCustomObject]) {
            $hash = @{}
            $InputObject.PSObject.Properties | ForEach-Object {
                $hash[$_.Name] = if ($_.Value -is [PSCustomObject]) {
                    ConvertTo-Hashtable $_.Value
                } else {
                    $_.Value
                }
            }
            return $hash
        }
        
        return $InputObject
    }
}

# Monitor de cola de comandos (Timer en UI thread)
function Start-CommandQueueMonitor {
    $timer = New-Object System.Windows.Forms.Timer
    $timer.Interval = 300
    
    $timer.Add_Tick({
        try {
            while ($Global:SharedState.CommandQueue.Count -gt 0) {
                try {
                    $comando = $Global:SharedState.CommandQueue.Dequeue()
                    
                    # Convertir PSCustomObject a Hashtable si es necesario
                    if ($comando -is [PSCustomObject]) {
                        $comando = ConvertTo-Hashtable $comando
                    }
                    
                    Write-Log "üì• Procesando: $($comando.tipo) - $($comando.accion)" -Tipo Info
                    
                    switch ($comando.tipo) {
                        "control_server" {
                            # Convertir comando completo a hashtable
                            $detalles = ConvertTo-Hashtable $comando
                            Invoke-AccionControl -Accion $comando.accion -Detalles $detalles
                        }
                        
                        "mensaje" {
                            try {
                                [System.Windows.Forms.MessageBox]::Show(
                                    $comando.texto,
                                    "Mensaje del Administrador",
                                    [System.Windows.Forms.MessageBoxButtons]::OK,
                                    [System.Windows.Forms.MessageBoxIcon]::Information
                                ) | Out-Null
                            }
                            catch { }
                        }
                        
                        "info" {
                            Invoke-AccionControl -Accion "ver_info" -Detalles @{}
                        }
                        
                        default {
                            Write-Log "‚ö†Ô∏è Comando desconocido: $($comando.tipo)" -Tipo Warning
                        }
                    }
                }
                catch {
                    Write-Log "‚ùå Error procesando comando: $_" -Tipo Error
                }
            }
        }
        catch {
            # Silenciar errores del timer
        }
    })
    
    $timer.Start()
    return $timer
}

# ============================================================
# üåê API REST
# ============================================================

function Invoke-ApiCall {
    param([hashtable]$ExtraBody = @{})
    
    $body = @{
        username = $Global:Config.Username
        mac_address = $Global:SharedState.MacAddress
    } + $ExtraBody
    
    $json = $body | ConvertTo-Json -Compress
    $headers = @{ "Content-Type" = "application/json" }
    
    try {
        $response = Invoke-RestMethod `
            -Uri $Global:Config.ApiUrl `
            -Method Post `
            -Headers $headers `
            -Body $json `
            -TimeoutSec 60
        
        return $response
    }
    catch {
        Write-Log "Error API: $($_.Exception.Message)" -Tipo Error
        return @{ estado = "Error"; mensaje = $_.Exception.Message }
    }
}

# ============================================================
# üñ•Ô∏è INTERFAZ GR√ÅFICA
# ============================================================

function New-SessionForm {
    $form = New-Object System.Windows.Forms.Form
    $form.Text = "Gesti√≥n de Sesi√≥n - AutoPr√©stamos"
    $form.Size = [System.Drawing.Size]::new(400, 200)
    $form.StartPosition = "Manual"
    $form.FormBorderStyle = [System.Windows.Forms.FormBorderStyle]::FixedDialog
    $form.ShowInTaskbar = $false
    $form.MinimizeBox = $true
    $form.MaximizeBox = $false
    
    $form.Location = [System.Drawing.Point]::new(
        [System.Windows.Forms.Screen]::PrimaryScreen.WorkingArea.Width - 400,
        [System.Windows.Forms.Screen]::PrimaryScreen.WorkingArea.Height - 250
    )
    
    # Logo
    $logo = New-Object System.Windows.Forms.PictureBox
    $logo.SizeMode = "StretchImage"
    $logo.Size = [System.Drawing.Size]::new(80, 80)
    $logo.Location = [System.Drawing.Point]::new(10, 10)
    
    if (Test-Path $Global:Config.LogoPath) {
        try { 
            $logo.Image = [System.Drawing.Image]::FromFile($Global:Config.LogoPath) 
        }
        catch { }
    }
    $form.Controls.Add($logo)
    
    # Label Info
    $labelInfo = New-Object System.Windows.Forms.Label
    $labelInfo.Font = New-Object System.Drawing.Font("Segoe UI", 12)
    $labelInfo.Location = [System.Drawing.Point]::new(100, 10)
    $labelInfo.AutoSize = $true
    $labelInfo.Text = "Usuario: $($Global:Config.Username)`nMAC: $($Global:SharedState.MacAddress)"
    $form.Controls.Add($labelInfo)
    
    # Label Timer
    $labelTimer = New-Object System.Windows.Forms.Label
    $labelTimer.Font = New-Object System.Drawing.Font("Segoe UI", 14, [System.Drawing.FontStyle]::Bold)
    $labelTimer.Location = [System.Drawing.Point]::new(30, 100)
    $labelTimer.AutoSize = $true
    $labelTimer.Text = "Inicializando..."
    $form.Controls.Add($labelTimer)
    
    # Indicador WebSocket
    $wsIndicator = New-Object System.Windows.Forms.Label
    $wsIndicator.Font = New-Object System.Drawing.Font("Segoe UI", 8)
    $wsIndicator.Location = [System.Drawing.Point]::new(10, 150)
    $wsIndicator.AutoSize = $true
    $wsIndicator.Text = "WS: Desconectado"
    $wsIndicator.ForeColor = [System.Drawing.Color]::Red
    $form.Controls.Add($wsIndicator)
    
    # Timer para actualizar indicador WS
    $wsTimer = New-Object System.Windows.Forms.Timer
    $wsTimer.Interval = 1000
    $wsTimer.Add_Tick({
        try {
            if ($Global:SharedState.WebSocketConnected) {
                $wsIndicator.Text = "WS: ‚úÖ Conectado"
                $wsIndicator.ForeColor = [System.Drawing.Color]::Green
            } else {
                $wsIndicator.Text = "WS: ‚ùå Desconectado"
                $wsIndicator.ForeColor = [System.Drawing.Color]::Red
            }
        }
        catch { }
    })
    $wsTimer.Start()
    
    # Bot√≥n Minimizar
    $btnReducir = New-Object System.Windows.Forms.Button
    $btnReducir.Text = "Minimizar"
    $btnReducir.Size = [System.Drawing.Size]::new(80, 28)
    $btnReducir.Location = [System.Drawing.Point]::new($form.Width - 100, $form.Height - 68)
    $btnReducir.Add_Click({
        try {
            if ($form.Height -gt 120) {
                $form.Size = [System.Drawing.Size]::new(280, 100)
                $logo.Size = [System.Drawing.Size]::new(170, 60)
                $btnReducir.Text = "Maximizar"
            } else {
                $form.Size = [System.Drawing.Size]::new(400, 200)
                $logo.Size = [System.Drawing.Size]::new(80, 80)
                $btnReducir.Text = "Minimizar"
            }
            $form.Refresh()
        }
        catch { }
    })
    $form.Controls.Add($btnReducir)
    
    return @{
        Form = $form
        LabelInfo = $labelInfo
        LabelTimer = $labelTimer
        WSIndicator = $wsIndicator
        WSTimer = $wsTimer
        Logo = $logo
        BtnReducir = $btnReducir
    }
}

# ============================================================
# üéÆ ESTADOS DE SESI√ìN
# ============================================================

function Invoke-EstadoAbierto {
    param($Controles, $Response)
    
    Write-Log "Estado: ABIERTO" -Tipo Success
    
    try {
        Start-Process -FilePath "explorer.exe" -ErrorAction SilentlyContinue
    }
    catch { }
    
    try {
        $Controles.LabelTimer.ForeColor = [System.Drawing.Color]::DarkGreen
        $tiempo = if ($Response.tiempo_restante) { $Response.tiempo_restante } else { 30 }
        
        for ($i = $tiempo; $i -ge 0; $i--) {
            $Controles.LabelTimer.Text = "üü¢ SESI√ìN ACTIVA - Restante: $(Format-TimeSpan $i)"
            $Controles.Form.Refresh()
            
            $waitUntil = (Get-Date).AddSeconds(1)
            while ((Get-Date) -lt $waitUntil) {
                [System.Windows.Forms.Application]::DoEvents()
                Start-Sleep -Milliseconds 50
            }
        }
    }
    catch {
        Write-Log "Error en countdown: $_" -Tipo Warning
    }
    
    return Invoke-ApiCall
}

# ============================================================
# üéÆ OTROS ESTADOS DE SESI√ìN
# ============================================================

function Invoke-EstadoBloqueado {
    param($Controles, $Response)
    
    Write-Log "Estado: BLOQUEADO" -Tipo Error
    
    try {
        $Controles.LabelTimer.ForeColor = [System.Drawing.Color]::Red
        
        # Verificar check-in de FOLIO
        if ($Response.folioCheckin -and 
            $Response.folioCheckin.raw -and 
            $Response.folioCheckin.raw.loan.status.name -eq "Closed") {
            
            Write-Log "Check-in detectado, actualizando estado..." -Tipo Info
            Start-Sleep -Seconds 1
            return Invoke-ApiCall
        }
        
        $tiempo = if ($Response.tiempo_restante) { $Response.tiempo_restante } else { 10 }
        
        for ($i = $tiempo; $i -ge 0; $i--) {
            $Controles.LabelTimer.Text = "üîí BLOQUEADO - Restante: $(Format-TimeSpan $i)"
            $Controles.Form.Refresh()
            
            $waitUntil = (Get-Date).AddSeconds(1)
            while ((Get-Date) -lt $waitUntil) {
                [System.Windows.Forms.Application]::DoEvents()
                Start-Sleep -Milliseconds 50
            }
        }
    }
    catch {
        Write-Log "Error en countdown bloqueado: $_" -Tipo Warning
    }
    
    return Invoke-ApiCall
}

function Invoke-EstadoSuspendido {
    param($Controles, $Response)
    
    Write-Log "Estado: SUSPENDIDO" -Tipo Warning
    
    try {
        $Controles.LabelTimer.ForeColor = [System.Drawing.Color]::Orange
        $Controles.LabelTimer.Text = "‚è∏Ô∏è SESI√ìN SUSPENDIDA"
        $Controles.Form.Refresh()
        
        # Mostrar modal de desbloqueo (simplificado)
        $resultado = [System.Windows.Forms.MessageBox]::Show(
            "Sesi√≥n suspendida. Ingrese OK para desbloquear con clave admin.",
            "Sesi√≥n Suspendida",
            [System.Windows.Forms.MessageBoxButtons]::OKCancel,
            [System.Windows.Forms.MessageBoxIcon]::Warning
        )
        
        if ($resultado -eq [System.Windows.Forms.DialogResult]::OK) {
            return Invoke-ApiCall -ExtraBody @{ clave_admin = $Global:Config.ClaveAdmin }
        }
        else {
            return Invoke-ApiCall -ExtraBody @{ cancel_suspend = "Cancelar" }
        }
    }
    catch {
        Write-Log "Error en estado suspendido: $_" -Tipo Error
        return Invoke-ApiCall
    }
}

function Invoke-EstadoRenovado {
    param($Controles, $Response)
    
    Write-Log "Estado: RENOVADO" -Tipo Info
    
    try {
        $Controles.LabelTimer.ForeColor = [System.Drawing.Color]::Blue
        $Controles.LabelTimer.Text = "‚ôªÔ∏è Renovaci√≥n en curso..."
        $Controles.Form.Refresh()
        
        Start-Sleep -Seconds 2
    }
    catch { }
    
    return Invoke-ApiCall
}

function Invoke-EstadoFinalizado {
    param($Controles, $Response)
    
    Write-Log "Estado: FINALIZADO" -Tipo Success
    
    try {
        $Controles.LabelInfo.ForeColor = [System.Drawing.Color]::Blue
        $Controles.LabelTimer.Text = "Sesi√≥n finalizada"
        $Controles.LabelTimer.ForeColor = [System.Drawing.Color]::Green
        $Controles.Form.Refresh()
        
        Start-Sleep -Seconds 3
        $Controles.Form.Close()
    }
    catch { }
}

function Invoke-EstadoRestringido {
    param($Controles, $Response)
    
    Write-Log "Estado: RESTRINGIDO" -Tipo Error
    
    try {
        $Controles.Form.Size = [System.Drawing.Size]::new(600, 400)
        $Controles.LabelInfo.ForeColor = [System.Drawing.Color]::Red
        $Controles.LabelInfo.Font = New-Object System.Drawing.Font("Segoe UI", 14, [System.Drawing.FontStyle]::Bold)
        $Controles.LabelInfo.Text = "üö´ ACCESO RESTRINGIDO"
        
        $txtBloqueos = New-Object System.Windows.Forms.TextBox
        $txtBloqueos.Multiline = $true
        $txtBloqueos.ScrollBars = "Vertical"
        $txtBloqueos.Font = New-Object System.Drawing.Font("Consolas", 10)
        $txtBloqueos.ReadOnly = $true
        $txtBloqueos.Size = [System.Drawing.Size]::new(560, 250)
        $txtBloqueos.Location = [System.Drawing.Point]::new(20, 80)
        $txtBloqueos.Text = "Usuario bloqueado en el sistema FOLIO.`n`nContacte al administrador para m√°s informaci√≥n."
        
        $Controles.Form.Controls.Add($txtBloqueos)
        $Controles.Form.Refresh()
        
        Start-Sleep -Seconds 5
        $Controles.Form.Close()
    }
    catch { }
}

function Invoke-EstadoError {
    param($Controles, $Response)
    
    Write-Log "Estado: ERROR - $($Response.mensaje)" -Tipo Error
    
    try {
        [System.Windows.Forms.MessageBox]::Show(
            $Response.mensaje,
            "‚ùå Error de Sesi√≥n",
            [System.Windows.Forms.MessageBoxButtons]::OK,
            [System.Windows.Forms.MessageBoxIcon]::Error
        ) | Out-Null
        
        $Controles.Form.Close()
    }
    catch { }
}

# ============================================================
# üöÄ INICIALIZACI√ìN Y BUCLE PRINCIPAL
# ============================================================

function Start-SessionLoop {
    Write-Log "Iniciando bucle principal de sesi√≥n..." -Tipo Info
    
    try {
        $controles = New-SessionForm
        $response = Invoke-ApiCall -ExtraBody @{ confirmar_inicio = "true" }
        
        if (-not $response.estado) {
            Write-Log "No se pudo obtener estado inicial" -Tipo Error
            return
        }
        
        # Iniciar monitor de comandos WebSocket
        $queueMonitor = Start-CommandQueueMonitor
        
        $controles.Form.Show()
        
        while ($response -and 
               $response.estado -ne "Finalizado" -and 
               $response.estado -ne "Restringido" -and
               $response.estado -ne "Error") {
            
            Write-Log "Estado actual: $($response.estado)" -Tipo Info
            
            try {
                switch ($response.estado) {
                    "Abierto" {
                        $response = Invoke-EstadoAbierto -Controles $controles -Response $response
                    }
                    
                    "Bloqueado" {
                        $response = Invoke-EstadoBloqueado -Controles $controles -Response $response
                    }
                    
                    "Suspendido" {
                        $response = Invoke-EstadoSuspendido -Controles $controles -Response $response
                    }
                    
                    "Renovado" {
                        $response = Invoke-EstadoRenovado -Controles $controles -Response $response
                    }
                    
                    default {
                        # Verificar si FOLIO cerr√≥ el pr√©stamo
                        if ($response.folioResp -and 
                            $response.folioResp.raw.loan.status.name -eq "Closed") {
                            Write-Log "Pr√©stamo cerrado en FOLIO" -Tipo Info
                            break
                        }
                        
                        Write-Log "Estado desconocido: $($response.estado)" -Tipo Warning
                        Start-Sleep -Seconds 2
                        $response = Invoke-ApiCall
                    }
                }
            }
            catch {
                Write-Log "Error procesando estado: $_" -Tipo Error
                Start-Sleep -Seconds 2
                $response = Invoke-ApiCall
            }
            
            Start-Sleep -Milliseconds 100
        }
        
        # Procesar estados finales
        if ($response.estado -eq "Finalizado") {
            Invoke-EstadoFinalizado -Controles $controles -Response $response
        }
        elseif ($response.estado -eq "Restringido") {
            Invoke-EstadoRestringido -Controles $controles -Response $response
        }
        elseif ($response.estado -eq "Error") {
            Invoke-EstadoError -Controles $controles -Response $response
        }
        
        # Cleanup
        try {
            $queueMonitor.Stop()
            $queueMonitor.Dispose()
            $controles.WSTimer.Stop()
            $controles.WSTimer.Dispose()
            $controles.Form.Close()
            $controles.Form.Dispose()
        }
        catch { }
        
        Write-Log "Bucle de sesi√≥n finalizado" -Tipo Success
    }
    catch {
        Write-Log "Error cr√≠tico en bucle de sesi√≥n: $_" -Tipo Error
    }
}

function Initialize-System {
    Write-Log "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -Tipo Info
    Write-Log "  SISTEMA DE AUTOPR√âSTAMOS - UNIVERSIDAD SIM√ìN BOL√çVAR" -Tipo Info
    Write-Log "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -Tipo Info
    
    # Detectar interfaz de red
    Write-Log "Detectando configuraci√≥n de red..." -Tipo Info
    $networkInfo = Get-ActiveNetworkInterface
    
    if (-not $networkInfo) {
        Write-Log "No se pudo detectar la red. Abortando..." -Tipo Error
        return $false
    }
    
    $Global:SharedState.MacAddress = $networkInfo.MAC
    
    # Verificar logo
    if (-not (Test-Path $Global:Config.LogoPath)) {
        Write-Log "Logo no encontrado (se continuar√° sin logo)" -Tipo Warning
    }
    
    # Conectar WebSocket
    Write-Log "Estableciendo conexi√≥n WebSocket..." -Tipo Info
    Start-WebSocketProcess
    
    Write-Log "‚è≥ Esperando inicializaci√≥n de WebSocket (3 seg)..." -Tipo Info
    Start-Sleep -Seconds 3
    
    if ($Global:SharedState.WebSocketConnected) {
        Write-Log "‚úÖ WebSocket conectado" -Tipo Success
    }
    else {
        Write-Log "‚ö†Ô∏è WebSocket no conectado (funcionar√° en modo degradado)" -Tipo Warning
    }
    
    Write-Log "‚úÖ Inicializaci√≥n completada" -Tipo Success
    return $true
}

function Clear-Resources {
    Write-Log "Limpiando recursos..." -Tipo Info
    
    try {
        Stop-WebSocketProcess
    }
    catch {
        Write-Log "Error al detener WebSocket: $_" -Tipo Warning
    }
    
    Write-Log "‚úÖ Recursos liberados" -Tipo Success
}

# ============================================================
# üé¨ PUNTO DE ENTRADA PRINCIPAL
# ============================================================

try {
    Clear-Host
    Write-Host ""
    Write-Host "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Cyan
    Write-Host "‚ïë                                                      ‚ïë" -ForegroundColor Cyan
    Write-Host "‚ïë    SISTEMA DE AUTOPR√âSTAMOS - UNISIM√ìN              ‚ïë" -ForegroundColor Cyan
    Write-Host "‚ïë    v2.2 - Arquitectura Dual Process                 ‚ïë" -ForegroundColor Cyan
    Write-Host "‚ïë    (Depuraci√≥n Completa)                            ‚ïë" -ForegroundColor Cyan
    Write-Host "‚ïë                                                      ‚ïë" -ForegroundColor Cyan
    Write-Host "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Cyan
    Write-Host ""
    
    # Inicializar sistema
    $initialized = Initialize-System
    
    if (-not $initialized) {
        Write-Log "Fallo en la inicializaci√≥n. Abortando..." -Tipo Error
        exit 1
    }
    
    # Ejecutar bucle de sesi√≥n
    Start-SessionLoop
    
    Write-Log "‚úÖ Ejecuci√≥n completada exitosamente" -Tipo Success
}
catch {
    Write-Log "‚ùå Error cr√≠tico: $($_.Exception.Message)" -Tipo Error
    Write-Log "Stack Trace: $($_.ScriptStackTrace)" -Tipo Error
}
# ============================================================
# FIN DEL SCRIPT - v2.2
# ============================================================